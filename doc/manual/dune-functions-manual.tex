% -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
% vi: set et ts=4 sw=2 sts=2:
\documentclass[a4paper,10pt,headings=normal,bibliography=totoc]{scrartcl}

\usepackage{scrhack}  % Fix a LaTeX warning

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{colonequals}
\usepackage{overpic}
\usepackage{url}
\usepackage{xspace}
\usepackage[square,numbers,sort]{natbib}

\usepackage[colorinlistoftodos]{todonotes}
%\usepackage[colorinlistoftodos,disable]{todonotes}
\usepackage{environ}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{float}


\usepackage{tikz}
\usetikzlibrary{arrows}
\tikzset{
    treenode/.style = {
        align=center,
        inner sep=0pt,
        text centered,
        font=\sffamily,
        rectangle,
        rounded corners=3mm,
        draw=black,
        minimum width=2em,
        minimum height=2em,
        inner sep=1mm,
        outer sep=0mm
    },
    smalltreenode/.style = {
        treenode,
        font=\footnotesize
    },
    basisnode/.style = {
        treenode,
        minimum width=9mm,
    },
    smallbasisnode/.style = {
        basisnode,
        font=\footnotesize
    }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%   hyperref should be loaded late to avoid incompatibilities
\usepackage[pdftitle={Function space bases in the dune-functions module},
            pdfauthor={Christian Engwer, Carsten Gräser, Steffen Müthing, and Oliver Sander}]
             {hyperref}

\usepackage{attachfile2}
\usepackage{fancyvrb}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%     Settings for the listings package
\lstset{language={c++},
         basicstyle=\ttfamily\small,
         keepspaces=true,
%         commentstyle=\textit,
         commentstyle=\rmfamily\textit,
%         columns=fixed,
         columns=flexible,
         escapeinside={/*@}{@*/},
         moredelim=**[is][\color{blue}]{@@}{@@},
        }

% How to include ranges of an external source code file
\lstset{rangeprefix=//\ \{\ ,% curly left brace plus space, all in a C++-style comment
        rangesuffix=\ \},% space plus curly right brace
        numberstyle=\footnotesize,  % font size for numbers
        includerangemarker=false}  % Do not show the range markers

\definecolor{interfacecolor}{rgb}{0.95,0.95,1}
\lstdefinestyle{Example}{}
%\lstdefinestyle{Interface}{backgroundcolor=\color{interfacecolor},frame=single,frameround={tttt}}
\lstdefinestyle{Interface}{backgroundcolor=\color{interfacecolor},frame=single}

\newcommand{\cpp}[1]{\lstinline[basicstyle=\ttfamily]!#1!}



\newtheorem{definition}{Definition}

%%%%%%%%%%%%%%    Define a 'shellenv' environment for shell output
\usepackage{fancyvrb}

\DefineVerbatimEnvironment%
 {shellenv}{Verbatim}
 {}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\abs}[1]{{\lvert#1\rvert}}
\newcommand{\norm}[1]{\lVert#1\rVert}
\newcommand{\op}[1]{\operatorname{#1}}
\newcommand{\st}{\; : \;}
\renewcommand{\div}{\operatorname{div}}
\DeclareMathOperator{\trace}{tr}

\newcommand{\dune}{\textsc{Dune}\xspace}
\newcommand{\program}[1]{\textsc{#1}\xspace}



% For typesetting Dune module names
\newcommand{\dunemodule}[1]{\texttt{#1}}
% For typesetting file names
\newcommand{\file}[1]{\texttt{#1}}

\definecolor{lightblue}{HTML}{55AAFF}

\newcommand{\todosander}[1]{\todo[inline,color=orange,author=OS]{#1}}
\newcommand{\todograeser}[1]{\todo[inline,color=lightblue,author=CG]{#1}}

%%  All graphics files must be in this subdirectory
\graphicspath{{gfx/}}

% Silence the infamous ``multiple pdfs with page group included in a single page'' warning
\pdfsuppresswarningpagegroup=1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Function space bases in the dune-functions module}
\author{Christian Engwer, Carsten Gräser,\\ Steffen Müthing, and Oliver Sander}
%\date{}

\begin{document}

\maketitle

\begin{abstract}
 The \dunemodule{dune-functions} \dune module provides interfaces for functions and function space bases.
 It forms one abstraction level above grids, shape functions, and linear algebra, and provides infrastructure
 for full discretization frameworks like \dunemodule{dune-pdelab} and \dunemodule{dune-fem}.
 This document describes the function space bases provided by \dunemodule{dune-functions}.  These are
 based on an abstract description of bases for product spaces as trees of simpler bases.
 From this description, many different numberings of degrees of freedom by multi-indices can be
 derived in a natural way. We describe the abstract concepts, document the programmer interface,
 and give a complete example program that solves the stationary Stokes equation using Taylor--Hood elements.
\end{abstract}

\section*{Introduction}

The core modules of the \dune software system focus on low-level infrastructure for
implementations of simulation algorithms for partial differential equations.  Modules like
\dunemodule{dune-grid} and \dunemodule{dune-istl} provide programmer interfaces (APIs) to finite element grids
and sparse linear algebra, respectively, but little more. Actual finite element functions only
appear in the \dunemodule{dune-localfunctions} module, which deals with discrete function spaces
on single grid elements exclusively.

On top of these core modules, various other modules in the \dune ecosystem implement finite element and finite volume assemblers
and solvers, and the corresponding discrete function spaces. The most prominent ones are
\dunemodule{dune-pdelab}%
\footnote{\url{https://dune-project.org/modules/dune-pdelab}}
%
and \dunemodule{dune-fem},%
\footnote{\url{https://dune-project.org/modules/dune-fem/}}
%
but smaller ones like \dunemodule{dune-fufem}%
\footnote{\url{https://dune-project.org/modules/dune-fufem/}}
%
exist as well.  The functionality of these modules overlaps to a considerable extent, even though
each such module has a different focus.

The \dunemodule{dune-functions}  module was written to partially overcome this fragmentation,
and to unify parts of the competing implementations.
It picks a well-defined aspect of finite element assembly---finite element spaces and functions---and,
in the \dune spirit, provides abstract interfaces that try to be both extremely flexibly
and efficient.  It is hoped for, that other implementations of the same functionality
eventually replace their implementations by a dependence on \dunemodule{dune-functions}.
Indeed, at least \dunemodule{dune-pdelab} and \dunemodule{dune-fufem} are already in the process
of migrating, and have stated their clear intention to complete this migration eventually.

Of the two parts of \dunemodule{dune-functions} functionality, the API for discrete and
closed-form functions has already been described in a separate paper~\cite{engwer_graeser_muething_sander:2015}.
The present document focuses on spaces of discrete functions.  However,
the central concept is not the function space itself, but rather the {\em basis} of the function space.
This is because even though finite element spaces play a central role in theoretical considerations of
the finite element method,
actual computations use coefficient vectors, which are defined with respect to a particular basis.  Also,
for various finite element spaces, more than one basis is used in practice.  For example,
the space of second-order Lagrangian finite elements is used both with the nodal (Lagrange) basis~\cite{braess:2013},
and with the
hierarchical basis~\cite{bank:1996}.  Discontinuous Galerkin spaces can be described in terms of Lagrange bases,
monomial bases, Legendre bases and more~\cite{hesthaven_warburton:2008}.
It is therefore important to be able to distinguish these different
representations of the same space in the application code.
For these reasons, the main \dunemodule{dune-functions} interface represents a basis of a
discrete function space, and not the space itself.

Finite element function space bases frequently exhibit a fair amount of structure.  Vector-valued spaces can be
written as products of scalar spaces, and the same holds for mixed finite elements.  Even more, such spaces
have a natural structure as a tree, with scalar-valued or otherwise irreducible spaces forming the leaves, and
products forming the inner nodes. The \dunemodule{dune-functions} module
allows to systematically construct new bases by multiplication of existing bases.
The resulting tree structure is reproduced as type information in the code.
This tree construction of finite element spaces has first been systematically worked out in~\cite{muething:2015}.

For the basis functions in such a non-trivial tree structure, there is no single canonical way
to index them.  Keeping all degrees of freedom in a single standard array would require indexing
by a contiguous, zero-starting set of natural numbers. On the other hand, from the tree structure
of the basis follows a natural indexing by multi-indices, which can be used to address nested
vector and matrix data types, like the ones provided by \dunemodule{dune-istl}. Closer inspection
reveals that these two possibilities are just two extreme cases of a wider scale of indexing rules.
The \dunemodule{dune-functions} module therefore provides a systematic way to construct such
rules.  While some of the resulting rules are somewhat contrived, many others really are useful
in applications.

The \dunemodule{dune-functions} module is hosted on the \dune project homepage \url{www.dune-project.org}.
Installation instructions and an up-to-date class documentation can be found there.

\setcounter{tocdepth}{2}  % Show only sections and subsections, but no more
\tableofcontents



\section{Function space bases}
\label{sec:finite_element_trees}


Before we can explain the programmer interface for bases of discrete function spaces in Chapter~\ref{sec:function_space_bases_implementation},
we need to say a few words about how these bases can be endowed with an abstract tree structure.
Readers who are only interested in finite element spaces of scalar-valued functions may try to proceed directly to
Chapter~\ref{sec:function_space_bases_implementation}.  They should only know that whenever a
local finite element tree
is mentioned there, this tree consists of a single node only, which is the local finite element basis.
Similarly, for a scalar finite element space the tree of multi-indices used to index the
basis functions simply represents a contiguous, zero-starting set of natural numbers.

\subsection{Trees of function spaces}

Throughout this paper we assume that we have a single fixed domain $\Omega$, and all function spaces
that we consider are defined on this domain.  We are mainly thinking of spaces of functions that are
piecewise polynomial with respect to a grid, but we do not actually require that yet.

For a set $R$ we denote by $R^\Omega = \{f:\Omega \to R\}$
the set of all functions mapping from $\Omega$ to $R$. For domains $\Omega\subset \R^d$
we denote by $P_k(\Omega) \subset \R^\Omega$ the space of all
scalar-valued continuous piecewise polynomials of degree at most $k$ on $\Omega$
with respect to some given triangulation.
If the domain $\Omega$ is fixed, we will simply write $P_k$.

Considering the different finite element spaces that are in use, there are some that we will
call \emph{irreducible}.  By this term we mean all bases of scalar-valued functions,
but also others like the Raviart--Thomas basis that cannot easily be written as a combination
of simpler bases.

Many other finite element spaces arise naturally as a combination of simpler ones.
There are primarily two ways how two vector spaces $V$ and $W$ can be combined
to form a new one: Sums and products. While these are also called
internal and external sums, respectively, we stick to the terminology
\emph{sum} and \emph{product} in the following.

For sums, both spaces need to
have the same range space $R$, and thus both be subspaces of $R^\Omega$.
Then the vector space sum
\begin{equation*}
  V + W
  \colonequals
  \{ v + w \; : \; v \in V, \; w \in W \}
\end{equation*}
in $R^\Omega$ will have that same range space.
For example, a $P_2$-space
can be viewed as a $P_1$-space plus a hierarchical extension spanned by bubble functions~\cite{bank:1996}.
XFEM spaces~\cite{moes_dolbow_belytschko:1999} are constructed by adding particular weighted Heaviside
functions to a basic space to capture free discontinuities.
The \dunemodule{dune-functions} module does not currently support constructing sums
of finite element bases, but this may be added in later versions.

The second way to construct finite element spaces from simpler ones uses Cartesian products.
Let $V \subset (\R^{r_1})^\Omega$ and $W \subset (\R^{r_2})^\Omega$ be two function spaces.
Then we define the product of $V$ and $W$ as
\begin{align*}
  V \times W
    \colonequals \big\{ (v,w) \st v \in V, \; w \in W \big\}.
\end{align*}
Functions from this space take values in $\R^{r_1} \times \R^{r_2} = \R^{r_1 + r_2}$.

It should be noted that building the Cartesian product of
vector spaces must not be confused with the tensor product of these spaces.
Rather, the $k$-th power
of a single space can be viewed as the tensor product of that space with $\R^k$, i.e,
\begin{align*}
    (V)^k
    = \underbrace{V \times \dots \times V}_{k-\text{times}}
    = \R^k \otimes V.
\end{align*}

The product operation allows to build vector-valued and mixed finite element spaces of arbitrary complexity.
For example, the space of
first-order Lagrangian finite elements with values in $\R^3$ can be seen as the product $P_1 \times P_1 \times P_1$.
The simplest Taylor--Hood element is the product $P_2 \times P_2 \times P_2 \times P_1$
of $P_2 \times P_2 \times P_2$ for the velocities with $P_1$ for the pressure.
More factor bases can be included easily, if necessary.  We call such products of
spaces \emph{composite spaces}.

In the Taylor--Hood space, the triple
$P_2 \times P_2 \times P_2$ forms a semantic unit---it contains the components of a velocity field.
The associativity of the product allows to write the Taylor--Hood space
as $(P_2 \times P_2 \times P_2) \times P_1$, which makes the semantic relationship clearer.
Grouped expressions of this type are conveniently visualized as tree structures.  This
suggests to interpret composite
finite element spaces as tree structures.  In this structure, leaf nodes represent scalar or otherwise irreducible spaces,
and inner nodes represent products of their children.  Subtrees then represent composite
finite element spaces.  Figure~\ref{fig:taylor_hood_space_tree} shows the Tayor--Hood finite element
space in such a tree representation. Note that in this document all trees are \emph{rooted} and \emph{ordered},
i.e., they have a dedicated root note, and the children of each node have a fixed given ordering.
Based on this child ordering we associate to each child the corresponding zero-based index.

\begin{figure}
    \begin{center}
        \begin{tikzpicture}[
                level/.style={
                    sibling distance = (3-#1)*2cm + 1cm,
                    level distance = 1.5cm
                }
            ]
            \node [treenode] {$(P_2\times P_2 \times P_2) \times P_1$}
                child{ node [treenode] {$P_2 \times P_2 \times P_2$}
                    child{ node [treenode] {$P_2$} }
                    child{ node [treenode] {$P_2$} }
                    child{ node [treenode] {$P_2$} }
                }
                child{ node [treenode] {$P_1$} };
        \end{tikzpicture}
    \end{center}
    \caption{Function space tree of the Taylor--Hood space $(P_2 \times P_2 \times P_2)\times P_1$}
    \label{fig:taylor_hood_space_tree}
\end{figure}

While these inner tree nodes might initially appear like useless artifacts of the tree representation, they are often extremely useful
because we can treat the subtrees rooted in those nodes as individual trees in their own right, which often makes it possible to
reuse existing algorithms that expect to operate on those subtrees in more complex settings.


\subsection{Trees of function space bases}
\label{sec:basistree}

The product of finite-dimensional spaces naturally induces a corresponding operation on bases
of such spaces.  We additionally introduce a generalized tensor product notation:
Consider ranges $R_0,\dots,R_{m-1}$ of function spaces $R_0^\Omega,\dots,R_{m-1}^\Omega$
and the $i$-th canonical basis vector $\mathbf{e}_i$ in $\R^m$.
Then
\begin{align*}
  \mathbf{e}_i \otimes f
  \colonequals (0,\dots,0,\underbrace{f}_{\text{$i$-th entry}},0,\dots,0)
  \in \prod_{j=0}^{m-1} \Bigl(R_j^\Omega\Bigr) = \Bigl(\prod_{j=0}^{m-1} R_j\Bigr)^\Omega,
\end{align*}
where $0$ in the $j$-th position denotes the zero-function in $R_j^\Omega$.
%denotes the function
%\begin{align*}
%  \mathbf{e}_i \otimes f &: \Omega \to \prod_{j=0}^{m-1} R_j, &
%  ((\mathbf{e}_i \otimes f)(x))_j &=
%  \begin{cases}
%    f(x) &\text{ if } i=j,\\
%    0 \in \R_j^\Omega &\text{ else}.
%  \end{cases}
%\end{align*}
Here and throughout the paper we will use zero based indices, i.e., $i,j\in \{0,\dots,m-1\}$.


Let $\Lambda_i$ be a function space basis of the space $V_i = \operatorname{span} \Lambda_i$
for $i=0,\dots,m-1$. Then a natural basis $\Lambda$ of the product space
\begin{align*}
  V_0 \times \dots \times V_{m-1}
  = \prod_{i=0}^{m-1} V_i
  = \prod_{i=0}^{m-1} \operatorname{span}\Lambda_i
\end{align*}
is given by
\begin{align}
  \label{eq:basis_product}
  \Lambda =
    \Lambda_0 \sqcup \dots \sqcup \Lambda_{m-1}
    = \bigsqcup_{i=0}^{m-1} \Lambda_i
    \colonequals \bigcup_{i=0}^{m-1} \mathbf{e}_i \otimes \Lambda_i.
\end{align}
Note that the symbol $\sqcup$ used here
is a simple short hand notation for \eqref{eq:basis_product}
and not to be understood as an associative binary operation.
Using this notation we have
\begin{align*}
  \operatorname{span} \Lambda
    = \operatorname{span} \bigl( \Lambda_0 \sqcup \dots \sqcup \Lambda_{m-1} \bigr)
%  = \prod_{i=0}^{m-1} \operatorname{span} \Lambda_i
    = (\operatorname{span} \Lambda_0) \times \dots \times (\operatorname{span} \Lambda_{m-1}).
\end{align*}

Similarly to the case of function spaces, bases can be interpreted as trees.
If we associate to each space $V$ in the function space tree a basis $\Lambda_V$,
then the induced natural function space basis tree is obtained by simply replacing
$V$ by $\Lambda_V$ in each node. For the Taylor--Hood basis this leads to the
function space basis tree depicted in Figure~\ref{fig:taylor_hood_basis_tree}.

\begin{figure}
    \begin{center}
        \begin{tikzpicture}[
                level/.style={
                    sibling distance = (3-#1)*2cm + 1cm,
                    level distance = 1.5cm
                }
            ]
            \node [treenode] {$(\Lambda_{P_2} \sqcup \Lambda_{P_2} \sqcup \Lambda_{P_2}) \sqcup  \Lambda_{P_1}$}
                child{ node [treenode] {$\Lambda_{P_2} \sqcup \Lambda_{P_2} \sqcup \Lambda_{P_2}$}
                    child{ node [treenode] {$\Lambda_{P_2}$} }
                    child{ node [treenode] {$\Lambda_{P_2}$} }
                    child{ node [treenode] {$\Lambda_{P_2}$} }
                }
                child{ node [treenode] {$\Lambda_{P_1}$} };
        \end{tikzpicture}
    \end{center}
    \caption{Function space basis tree of the Taylor--Hood space $(P_2 \times P_2 \times P_2)\times P_1$}
    \label{fig:taylor_hood_basis_tree}
\end{figure}



\subsection{Indexing basis functions by multi-indices}
\label{sec:index_trees}

To work with the basis of a finite element space, the basis functions need to be indexed.  Indexing the basis functions
is what allows to address the corresponding vector and matrix coefficients in suitable vector and matrix data structures.
In simple cases, indexing means simply enumerating the basis functions with natural numbers, but for many applications
hierarchically structured matrix and vector data structures are more natural or efficient.  This leads to the idea
of hierarchically structured multi-indices.
%
\begin{definition}[Multi-indices]
 A tuple $I \in \N_0^k$ for some $k \in \N_0$ is called a multi-index of length $k$,
 and we write $|I|=k$.
 The set of all multi-indices is denoted by
 $\mathcal{N} = \bigcup_{k \in \N_0} \N_0^k$.
\end{definition}
%
To establish some structure in a set of multi-indices it is convenient to consider prefixes.
%
\begin{definition}\mbox{}  % Force a line break, otherwise the enumeration looks funny
    \begin{enumerate}
        \item
            If $I \in \mathcal{N}$ takes the form $I = (I^0,I^1)$ for $I^0,I^1 \in \mathcal{N}$,
            then we call $I^0$ a prefix of $I$.
            If additionally $|I^1|>0$, then we call $I^0$ a strict prefix of $I$.
        \item
            For $I,I^0 \in \mathcal{N}$ and a set $\mathcal{M} \subset \mathcal{N}$:
            \begin{enumerate}
              \item
                We write $I=(I^0,\dots)$, if $I^0$ is a prefix of $I$,
              \item
                we write $I=(I^0,\cdot,\dots)$, if $I^0$ is a strict prefix of $I$,
              \item
                we write $(I^0,\dots) \in \mathcal{M}$, if $I^0$ is a prefix of some
                $I \in \mathcal{M}$,
              \item
                we write $(I^0,\cdot,\dots) \in \mathcal{M}$, if $I^0$ is a strict prefix of some
                $I \in \mathcal{M}$.
            \end{enumerate}
    \end{enumerate}
\end{definition}

It is important to note that the multi-indices from a given set do not necessarily
all have the same length.
Figure~\ref{fig:taylor_hood_basis_function_tree} illustrates the set of all basis
functions by extending the ordered basis tree of Figure~\ref{fig:taylor_hood_basis_tree}
by leaf nodes for individual basis functions.
For example, a possible indexing of the basis functions of the Taylor--Hood basis $\Lambda_{TH}$
uses multi-indices of the form $(0,i,j)$ for velocity components, and $(1,k)$
for pressure components.
For the velocity multi-indices $(0,i,j)$ the $i = 0,\dots,n_2-1 \colonequals \abs{\Lambda_{P_2}}-1$ determines the component
of the velocity vector field and the $j$ determines the number of the scalar $P_2$ basis
function that determines this component.
For the pressure multi-indices $(0,k)$ the $k= 0,\dots,n_1-1 \colonequals \abs{\Lambda_{P_1}}-1$ determines the number of the $P_1$ basis
function for the scalar $P_1$ function that determines the pressure.

\begin{figure}
    \begin{center}
        \begin{tikzpicture}[
                level/.style={
                    sibling distance = (3-#1)*2cm + 1cm,
                    level distance = 1.5cm
                }
            ]
            \node [treenode] {$(\Lambda_{P_2} \sqcup \Lambda_{P_2} \sqcup \Lambda_{P_2}) \sqcup  \Lambda_{P_1}$}
                child[sibling distance = 7cm]{ node [treenode] {$\Lambda_{P_2} \sqcup \Lambda_{P_2} \sqcup \Lambda_{P_2}$}
                    child [sibling distance = 3.3cm] { node [treenode] {$\Lambda_{P_2}$}
                        child{ node [basisnode] {$\lambda_0^{P_2}$} }
                        child{ node [] {$\dots$} }
                        child{ node [basisnode] {$\lambda_{n_2-1}^{P_2}$} }
                    }
                    child [sibling distance = 3.3cm] { node [treenode] {$\Lambda_{P_2}$}
                        child{ node [basisnode] {$\lambda_0^{P_2}$} }
                        child{ node [] {$\dots$} }
                        child{ node [basisnode] {$\lambda_{n_2-1}^{P_2}$} }
                    }
                    child [sibling distance = 3.3cm] { node [treenode] {$\Lambda_{P_2}$}
                        child{ node [basisnode] {$\lambda_0^{P_2}$} }
                        child{ node [] {$\dots$} }
                        child{ node [basisnode] {$\lambda_{n_2-1}^{P_2}$} }
                    }
                }
                child{ node [treenode] {$\Lambda_{P_2}$}
                    child [sibling distance=1cm] { node [basisnode] {$\lambda_0^{P_1}$} }
                    child [sibling distance=1cm] { node [] {$\dots$} }
                    child [sibling distance=1cm] { node [basisnode] {$\lambda_{n_1-1}^{P_1}$} }
                };
        \end{tikzpicture}
    \end{center}
    \caption{Tree of basis vectors for the Taylor--Hood basis}
    \label{fig:taylor_hood_basis_function_tree}
\end{figure}

It is evident that the complete set of these multi-indices can again be interpreted as a rooted tree.
In this tree, the multi-indices correspond
to the leaf nodes, and the multi-index digits labeling the edges are the
(zero-based) indices of the children within the ordered tree.  Prefixes can be
interpreted as paths from the root to a given node.

This latter fact can be seen as the defining property of index trees.  Indeed,
sets of multi-indices form trees as long as they are consistent in the sense that they
can be viewed as the paths to the leafs in an ordered tree.
That is, the children of each node are enumerated using consecutive zero-based
indices and paths to the leafs (i.e., the multi-indices) are built by concatenating
those indices starting from the root and ending in a leaf.

\begin{definition}
 A set $\mathcal{I} \subset \mathcal{N}$ is called an \emph{index tree}
 if for any $(I,i,\dots) \in \mathcal{I}$ there are also $(I,0,\dots),(I,1,\dots),\dots,(I,i-1,\dots) \in \mathcal{I}$,
 but $I \notin \mathcal{I}$.
\end{definition}
The index tree for the example indexing of the Taylor--Hood basis given above is shown
in Figure~\ref{fig:taylor_hood_index_tree}.

\begin{figure}
    \begin{center}
        \begin{tikzpicture}[
                level/.style={
                    sibling distance = (3-#1)*2.5cm + 1cm,
                    level distance = 1.5cm
                }
            ]
            \node [smalltreenode] {$()$}
                child [sibling distance=70mm] { node [smalltreenode] {$( 0 )$}
                    child [sibling distance=44mm] { node [smalltreenode] {$( 0,0 )$}
                        child [sibling distance=14mm] { node [smallbasisnode] {$( 0,0,0 )$} edge from parent node[left] {$0$}}
                        child [sibling distance=14mm] { node [] {$\dots$} }
                        child [sibling distance=14mm] { node [smallbasisnode] {$( 0,0,n_2-1 )$} edge from parent node[right] {$n_2-1$} }
                        edge from parent node[above left] {$0$}
                    }
                    child [sibling distance=44mm] { node [smalltreenode] {$( 0,1 )$}
                        child [sibling distance=14mm] { node [smallbasisnode] {$( 0,1,0 )$} edge from parent node[left] {$0$}}
                        child [sibling distance=14mm] { node [] {$\dots$} }
                        child [sibling distance=14mm] { node [smallbasisnode] {$( 0,1,n_2-1 )$} edge from parent node[right] {$n_2-1$} }
                        edge from parent node[left] {$1$}
                    }
                    child [sibling distance=44mm] { node [smalltreenode] {$( 0,2 )$}
                        child [sibling distance=14mm] { node [smallbasisnode] {$( 0,2,0 )$} edge from parent node[left] {$0$}}
                        child [sibling distance=14mm] { node [] {$\dots$} }
                        child [sibling distance=14mm] { node [smallbasisnode] {$( 0,2,n_2-1 )$} edge from parent node[right] {$n_2-1$} }
                        edge from parent node[above right] {$2$}
                    }
                    edge from parent node[above left] {$0$}
                }
                child [sibling distance=70mm] { node [smalltreenode] {$( 1 )$}
                    child [sibling distance=1cm] { node [smallbasisnode] {$( 1,0 )$} edge from parent node[above left] {$0$} }
                    child [sibling distance=1cm] { node [] {$\dots$} }
                    child [sibling distance=1cm] { node [smallbasisnode] {$( 1,n_1-1 )$} edge from parent node[above right] {$n_1-1$} }
                    edge from parent node[above right] {$1$}
                };
        \end{tikzpicture}
    \end{center}
    \caption{Index tree for the Taylor--Hood basis inherited from the basis tree}
    \label{fig:taylor_hood_index_tree}
\end{figure}


\begin{definition}
Let $(I,\dots) \in \mathcal{I}$, i.e., $I$ is a
prefix of multi-indices in $\mathcal{I}$. Then the size of $\mathcal{I}$ relative
to $I$ is given by
\begin{align}\label{eq:prefix_size}
  \operatorname{deg}^+_{\mathcal{I}}[I] \colonequals  \op{max}\{k \st \exists (I,k,\dots) \in \mathcal{I} \}+1.
\end{align}
\end{definition}
In terms of the ordered tree associated with $\mathcal{I}$ this corresponds
to the out-degree of $I$, i.e., the number of direct children of the node indexed by $I$.

Using the idea of multi-index trees,
an indexing of a function space basis is an injective map from the leaf nodes of a tree of basis functions to the leafs of an
index tree.

\begin{definition}
  Let $M$ a finite set and $\iota:M \to \mathcal{N}$ an injective map whose range
  $\iota(M)$ forms an index tree.
  Then $\iota$ is called an \emph{index-map} for $M$.
  The index map is called \emph{uniform} if additionally $\iota(M) \subset \mathbb{N}^k_0$ for some $k \in \mathbb{N}$,
  and \emph{flat} if $\iota(M) \subset \mathbb{N}_0$.
\end{definition}

Continuing the Taylor--Hood example, if
all basis functions $\Lambda_{TH} = \{\lambda_I \}$ of the whole finite element tree are
indexed by multi-indices of the above given form,
and if $X$ is a coefficient vector that has a compatible hierarchical structure,
then a finite element function $(v_h,p_h)$ with velocity
$v_h$ and pressure $p_h$ defined by the coefficient vector $X$
is given by
\begin{align*}
  (v_h,p_h)
  &= \sum_{i=0}^2\sum_{j=0}^{n_2-1} X_{(0,i,j)}\lambda_{(0,i,j)}
  + \sum_{k=0}^{n_1-1} X_{(1,k)}\lambda_{(1,k)},
\end{align*}
with basis functions
\begin{equation*}
  \lambda_{(0,i,j)} = \mathbf{e}_0 \otimes (\mathbf{e}_i \otimes \lambda^{P_2}_j), \qquad i=0,1,2,
    \qquad \text{and} \qquad
    \lambda_{(1,k)} = \mathbf{e}_1 \otimes \lambda^{P_1}_k.
\end{equation*}
Introducing the corresponding index map $\iota : \Lambda_{\text{TH}} \to \mathcal{N}$
with $\iota(\Lambda_I)=I$ on the set $\Lambda_{\text{TH}}$ of all basis functions
we can write this in compact form as
\begin{align*}
  (v_h,p_h) &= \sum_{\lambda \in \Lambda_{\text{TH}}} X_{\iota(\lambda)} \lambda
            = \sum_{I \in \iota(\Lambda_{\text{TH}})} X_I \lambda_I.
\end{align*}
Alternatively the individual velocity and pressure fields
$v_h$ and $p_h$ are given by
\begin{align*}
  v_h &= \sum_{j=0}^{n_2-1} X_{(0,i,j)} (\mathbf{e}_i \otimes \lambda^{P_2}_j),
    &
    p_h &= \sum_{k=0}^{n_1-1} X_{(1,k)}\lambda^{P_1}_k.
\end{align*}

\begin{figure}
    \begin{center}
        \begin{tikzpicture}[
                level/.style={
                    sibling distance = (3-#1)*2cm + 1cm,
                    level distance = 1.5cm
                },
            ]
            \node [treenode] {$()$}
                child{ node [treenode] {$( 0 )$}
                        child [sibling distance=2.5cm] { node [smalltreenode] {$( 0,0 )$}
                            child [sibling distance=1.5cm] { node [smallbasisnode] {$( 0,0,0 )$} edge from parent node[above left] {$0$}}
                            child [sibling distance=1.5cm] { node [smallbasisnode] {$( 0,0,1 )$} edge from parent node[left] {$1$}}
                            child [sibling distance=1.5cm] { node [smallbasisnode] {$( 0,0,2 )$} edge from parent node[above right] {$2$}}
                            edge from parent node[above left] {$0$}
                        }
                        child [sibling distance=2.3cm]{ node [] {$\dots$} }
                        child [sibling distance=2.6cm]{ node [smalltreenode] {$( 0,n_2-1 )$}
                            child [sibling distance=2cm] { node [smallbasisnode] {$( 0,n_2 - 1,0 )$} edge from parent node[above left] {$0$}}
                            child [sibling distance=2cm] { node [smallbasisnode] {$( 0,n_2 - 1,1 )$} edge from parent node[left] {$1$}}
                            child [sibling distance=2cm] { node [smallbasisnode] {$( 0,n_2 - 1,2 )$} edge from parent node[above right] {$2$}}
                            edge from parent node[above right] {$n_2-1$}
                        }
                        edge from parent node[above left] {$0$}
                }
                child [sibling distance=6.2cm]{ node [smalltreenode] {$( 1 )$}
                    child [sibling distance=1.3cm] { node [smallbasisnode] {$( 1,0 )$} edge from parent node[above left] {$0$} }
                    child [sibling distance=1.3cm] { node [] {$\dots$} }
                    child [sibling distance=1.3cm] { node [smallbasisnode] {$( 1,n_1-1 )$} edge from parent node[above right] {$n_1-1$} }
                    edge from parent node[above right] {$1$}
                };
        \end{tikzpicture}
    \end{center}
    \caption{Index tree for Taylor--Hood with blocking of local velocity components}
    \label{fig:taylor_hood_index_blocked_tree}
\end{figure}


In the previous example, the index tree was
isomorphic to the basis function tree depicted in Figure~\ref{fig:taylor_hood_basis_function_tree}.
However, one may also be interested in constructing multi-indices
that do not mimic the structure of the basis function tree:
For example, to increase data locality in assembled matrices for the Taylor--Hood basis it may be
preferable to group all velocity degrees of freedom corresponding to a single
$P_2$ basis function together, i.e., to use the index $(0,j,i)$
for the $j$-th $P_2$ basis function for the $i$-th component.
The corresponding alternative index tree is shown in
Figure~\ref{fig:taylor_hood_index_blocked_tree}.
Figure~\ref{fig:matrix_occupation_patterns} shows the corresponding layouts of a hierarchical stiffness matrix.

\begin{figure}
 \begin{center}
  \begin{tikzpicture}[scale=.13]

  % The occupation pattern
  \foreach \x in {0,...,32}
    \fill [lightgray] (0+\x,40-\x) rectangle (1+\x,39-\x);

  % The fine grid
  \foreach \x in {0,...,40}
    \draw (\x,0)--(\x,40);

  \foreach \y in {0,...,40}
    \draw (0,\y)--(40,\y);

  % The thick-line grid
  \foreach \x in {0,11,22,33,40}
    \draw [line width=0.4mm] (\x,0)--(\x,40);

  \foreach \y in {0,7,18,29,40}
    \draw [line width=0.4mm] (0,\y)--(40,\y);

  \end{tikzpicture}
  \qquad
  \begin{tikzpicture}[scale=.13]

  % The occupation pattern
  \foreach \x in {0,...,9}
    \fill [lightgray] (0+3*\x,40-3*\x) rectangle (3+3*\x,37-3*\x);

  % The fine grid
  \foreach \x in {0,...,10}
    \draw (3*\x,0)--(3*\x,40);

  \foreach \y in {0,...,10}
    \draw (0,40-3*\y)--(40,40-3*\y);

  \foreach \x in {0,...,9}
    \draw (40 - 1*\x,0)--(40 - 1*\x,40);

  \foreach \y in {0,...,9}
    \draw (0,\y)--(40,\y);

  % The thick-line grid
  \foreach \x in {0,30,40}
    \draw [line width=0.4mm] (\x,0)--(\x,40);

  \foreach \y in {0,10,40}
    \draw [line width=0.4mm] (0,\y)--(40,\y);

  \end{tikzpicture}
 \end{center}
 \caption{Two matrix occupation patterns for different indexings of the Taylor--Hood bases.
   Left: Corresponding to the index tree of Figure~\ref{fig:taylor_hood_index_tree}.
   Right: Corresponding to the index tree of Figure~\ref{fig:taylor_hood_index_blocked_tree}.
   \todosander{Die Matrizen müssen dichter besetzt sein, und die Linien etwas dünner.}
   }
 \label{fig:matrix_occupation_patterns}
\end{figure}

Alternatively, the case of indexing all basis functions from the Taylor--Hood basis with a single
natural number can be represented by an index tree with $3 n_2 + n_1$ leaf nodes all
directly attached to a single root. Different variations of such a tree differ by how the
degrees of freedom are ordered.




\subsection{Strategy-based construction of multi-indices}
\label{sec:index_strategies}

Let $\Lambda$ be the set of basis functions of a finite element basis tree.
In principle, \dunemodule{dune-functions} allows any indexing scheme that
is given by an index map $\iota: \Lambda \to \mathcal{N}$,
i.e., $\iota$ is injective and its range $\iota(\Lambda)$ is an index tree.  In practice,
out of this large set of maps, \dunemodule{dune-functions} allows to construct the most
important ones systematically using certain transformation rules.

Consider a tree of function space bases in the sense of Section~\ref{sec:basistree}.
We want to construct an indexing for this tree, that is
an index tree $\mathcal{I}$ and a bijection $\iota$ from the set of all basis functions $\Lambda$
to the multi-indices in $\mathcal{I}$. This construction proceeds recursively.
To describe it,
we assume in the following that $\Lambda$ is a node in the function space
basis tree, i.e., it is the set of all basis functions
corresponding to a node $V=\operatorname{span} \Lambda$
in the function space tree.

To end the recursion, we assume that an index map $\iota : \Lambda \to \mathcal{N}$
is given if $V = \operatorname{span} \Lambda$ is a leaf node of the function space tree.
The most obvious choice would be a flat zero-based index
of the basis functions of $\Lambda$. However, other choices are possible.
For example, in case of a discontinuous finite element space, each
basis function $\lambda \in \Lambda$ can also be associated to a multi-index $\iota(\lambda)=(i,k)$ where $i$ is the
index of the grid element that forms the support of $\lambda$, and $k$ is the index of $\lambda$
within this element.

If $\Lambda$ is any non-leaf node in the function space basis tree,
then it takes the form
\begin{align*}
  \Lambda = \Lambda_0 \sqcup \dots \sqcup \Lambda_{m-1}
          = \bigcup_{i=0}^{m-1} \mathbf{e}_i \otimes \Lambda_i,
\end{align*}
where $\Lambda_0, \dots,\Lambda_{m-1}$ are the direct children of $\Lambda$,
i.e., the sets of basis functions of the child
spaces $\{\operatorname{span} \Lambda_i\}_{i=0,\dots,m-1}$ of the product space
\begin{align*}
  \operatorname{span} \Lambda
    = \operatorname{span} \bigl( \Lambda_0 \sqcup \dots \sqcup \Lambda_{m-1} \bigr)
%  = \prod_{i=0}^{m-1} \operatorname{span} \Lambda_i
    = (\operatorname{span} \Lambda_0) \times \dots \times (\operatorname{span} \Lambda_{m-1}).
\end{align*}
For the recursive construction we assume that an index-map
$\iota_i : \Lambda_i \to \mathcal{N}$ on $\Lambda_i$ is given for any $i=0,\dots,m-1$.
The task is to construct an index map $\iota: \Lambda \to \mathcal{N}$
from the maps $\iota_i$.
In the following we describe four strategies to achieve this; all
have been implemented in \dunemodule{dune-functions}. When reading about these
strategies, remember that any $\lambda \in \Lambda$ has a unique representation
$\lambda = \mathbf{e}_i \otimes \hat{\lambda}$ for $i \in \{0,\dots,m-1\}$ and some
$\hat{\lambda} \in \Lambda_i$.
It will be necessary to distinguish the special case that all children
$\Lambda_i$ are identical.
%
\begin{definition}
\label{def:power_node}
  An inner node $\Lambda$ will be called \emph{power node}, if all of its children $\Lambda_i$
  are identical and equipped with identical index-maps $\iota_i$.
  An inner node that is not a power node is called \emph{composite node}.
\end{definition}
%
This definition is needed because some of the following strategies can only be applied
to power nodes.
\begin{itemize}
  \item
    \textbf{BlockedLexicographic}: This strategy prepends the child index
    to the multi-index within the child basis. That is, the index map $\iota:\Lambda \to \mathcal{N}$
    is given by
    \begin{align*}
      \iota(\mathbf{e}_i \otimes \hat{\lambda}) = (i,\iota_i(\hat{\lambda})).
    \end{align*}
    It is straightforward to show that $\iota$ is always an index-map
    for $\Lambda$.
    To demonstrate the strategy the following table shows the multi-indices at inner nodes,
    when the basis functions of the subtrees $\Lambda_0, \Lambda_1,\dots$ are labeled by
    multi-indices $(I^0), (I^1), \dots$ for $\Lambda_0$, $(K^0), (K^1), \dots$ for $\Lambda_1$,
    and so on.

    \begin{tabular}{c|c|c|c}
      indices for $\Lambda_0$ &
      indices for $\Lambda_1$ &
      indices for $\dots$ &
      indices for $\Lambda$ \\
      \hline
      $\iota_0(\hat{\lambda}_{0,0}) = (I^0)$ & & &
        $\iota(\mathbf{e}_0 \otimes \hat{\lambda}_{0,0}) = (0,I^0)$ \\
      $\iota_0(\hat{\lambda}_{0,1}) = (I^1)$ & & &
        $\iota(\mathbf{e}_0 \otimes \hat{\lambda}_{0,1}) = (0,I^1)$ \\
      & $\iota_1(\hat{\lambda}_{1,0}) = (K^0)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,0}) = (1,K^0)$ \\
      & $\iota_1(\hat{\lambda}_{1,1}) = (K^1)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,1}) = (1,K^1)$ \\
      & $\iota_1(\hat{\lambda}_{1,2}) = (K^2)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,2}) = (1,K^2)$ \\
      & & \dots &
        \dots \\
    \end{tabular}

  \item
    \textbf{BlockedInterleaved}: This strategy is only well-defined for power nodes. It appends the child index
    to the multi-index within the child basis.
    That is, the index map $\iota:\Lambda \to \mathcal{N}$
    is given by
    \begin{align*}
      \iota(\mathbf{e}_i \otimes\hat{\lambda}) = (\iota_i(\hat{\lambda}),i).
    \end{align*}
    An example is given in the following table:

    \begin{tabular}{c|c|c|c}
      indices for $\Lambda_0$ &
      indices for $\Lambda_1$ &
      indices for $\dots$ &
      indices for $\Lambda$ \\
      \hline
      $\iota_0(\hat{\lambda}_{0,0}) = (I^0)$ & & &
        $\iota(\mathbf{e}_0 \otimes \hat{\lambda}_{0,0}) = (I^0,0)$ \\
      & $\iota_1(\hat{\lambda}_{1,0}) = (I^0)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,0}) = (I^0,1)$ \\
      & & \dots &
        \dots \\
      $\iota_0(\hat{\lambda}_{0,1}) = (I^1)$ & & &
        $\iota(\mathbf{e}_0 \otimes \hat{\lambda}_{0,1}) = (I^1,0)$ \\
      & $\iota_1(\hat{\lambda}_{1,1}) = (I^1)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,1}) = (I^1,1)$ \\
      & & \dots &
        \dots \\
      $\iota_0(\hat{\lambda}_{0,2}) = (I^2)$ & & &
        $\iota(\mathbf{e}_0 \otimes \hat{\lambda}_{0,2}) = (I^2,0)$ \\
      & $\iota_1(\hat{\lambda}_{1,2}) = (I^2)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,2}) = (I^2,1)$ \\
      & & \dots &
        \dots \\
    \end{tabular}

    To see that this strategy does not work for general composite nodes,
    consider $\iota_0(\Lambda_0) = \{0\}$ and $\iota_1(\Lambda_1) = \{(0,0)\}$.
    Then $\iota(\Lambda) = \{(0,0), (0,0,1)\}$ which is not an index tree.
\end{itemize}
Unlike the previous two rules, the following two do not introduce new
multi-index digits.
\begin{itemize}
  \item \textbf{FlatLexicographic}: This strategy introduces
    a new root node in the index tree by merging the roots of all
    index-tree $\iota_i(\Lambda_i)$ into a single one.
    Assume that we split the multi-index
    $\iota_i(\hat{\lambda})$ according to
    \begin{align}\label{eq:multiindex-split}
      \iota_i(\hat{\lambda}) = (i_0,I),
    \end{align} 
    where $i_0 \in \mathbb{N}_0$ is the first digit.
    The index map $\iota:\Lambda \to \mathcal{N}$ is then given by
    \begin{align*}
      \iota(\mathbf{e}_i \otimes\hat{\lambda}) = (L_i + i_0, I),
    \end{align*}
    where the offset $L_i$ for the first digit is computed by
    \begin{align*}
      L_i = \sum_{j=0}^{i-1} \operatorname{deg}_{\iota_j(\Lambda_j)}^+[()].
    \end{align*}
    This construction shifts the first digits of
    the multi-indices of all basis functions from $\Lambda_j$ with $j<0$
    such that they form a consecutive sequence.
    This guarantees that $\iota$ is always an index-map for $\Lambda$.
    An example is given in the following table:

    \begin{tabular}{c|c|c|c}
      indices for $\Lambda_0$ &
      indices for $\Lambda_1$ &
      indices for $\dots$ &
      indices for $\Lambda$ \\
      \hline
      $\iota_0(\hat{\lambda}_{0,0}) = (0,I^0)$ & & &
        $\iota(\mathbf{e}_0 \otimes \hat{\lambda}_{0,0}) = (0,I^0)$ \\
      $\iota_0(\hat{\lambda}_{0,1}) = (1,I^1)$ & & &
        $\iota(\mathbf{e}_0 \otimes \hat{\lambda}_{0,1}) = (1,I^1)$ \\
      & $\iota_1(\hat{\lambda}_{1,0}) = (0,K^0)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,0}) = (2,K^0)$ \\
      & $\iota_1(\hat{\lambda}_{1,1}) = (0,K^1)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,1}) = (2,K^1)$ \\
      & $\iota_1(\hat{\lambda}_{1,2}) = (1,K^2)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,2}) = (3,K^2)$ \\
      & & \dots &
        \dots \\
    \end{tabular}

    This merging strategy is called \emph{flat}, because no
    additional multi-index digits are inserted to address the different children.

  \item \textbf{FlatInterleaved}: This strategy again only works for power nodes.
    It also merges
    the roots of all child index-trees $\iota_i(\Lambda_i)$
    into a single one, but it interleaves the children.
    Again using the splitting
    $\iota_i(\hat{\lambda}) = (i_0,I)$ introduced in~\eqref{eq:multiindex-split},
    the index map $\iota:\Lambda \to \mathcal{N}$ is given by
    \begin{align*}
      \iota(\mathbf{e}_i \otimes\hat{\lambda}) = (i_0 m + i, I),
    \end{align*}
    where the fixed stride $m$ is given by the number of children of $\Lambda$.
    The following table shows an example:

    \begin{tabular}{c|c|c|c}
      indices for $\Lambda_0$ &
      indices for $\Lambda_1$ &
      indices for $\dots$ &
      indices for $\Lambda$ \\
      \hline
      $\iota_0(\hat{\lambda}_{0,0}) = (0,I^0)$ & & &
        $\iota(\mathbf{e}_0 \otimes \hat{\lambda}_{0,0}) = (0,I^0)$ \\
      & $\iota_1(\hat{\lambda}_{1,0}) = (0,I^0)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,0}) = (1,I^0)$ \\
      & & \dots &
        \dots \\
      $\iota_0(\hat{\lambda}_{0,1}) = (1,I^1)$ & & &
        $\iota(\mathbf{e}_0 \otimes \hat{\lambda}_{0,1}) = (m+0,I^1)$ \\
      & $\iota_1(\hat{\lambda}_{1,1}) = (1,I^1)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,1}) = (m+1,I^1)$ \\
      & & \dots &
        \dots \\
      $\iota_0(\hat{\lambda}_{0,2}) = (2,I^2)$ & & &
        $\iota(\mathbf{e}_0 \otimes \hat{\lambda}_{0,2}) = (2m+0,I^2)$ \\
      & $\iota_1(\hat{\lambda}_{1,2}) = (2,I^2)$ & &
        $\iota(\mathbf{e}_1 \otimes \hat{\lambda}_{1,2}) = (2m+1,I^2)$ \\
      & & \dots &
        \dots \\
    \end{tabular}

    Again, for this interleaved strategy, $\iota$ might not be an
    index-map for general composite nodes.
\end{itemize}

These four strategies are offered by \dunemodule{dune-functions}, but there are others
that are sometimes useful.  Experimentally, \dunemodule{dune-functions} therefore also
provides a way to use self-implemented custom rules.

\bigskip

To further illustrate the four index transformation strategies, we return to
the Taylor--Hood example.
While the indexing schemes proposed for this example so far where
introduced in an ad-hoc way, we will now systematically apply
the above given strategies.  Recall that the Taylor--Hood basis is denoted by
\begin{align*}
 \Lambda_\text{TH}
  = (\Lambda_{P_2} \sqcup \Lambda_{P_2} \sqcup \Lambda_{P_2}) \sqcup \Lambda_{P_1}.
\end{align*}
For the bases $\Lambda_{P_1}, \Lambda_{P_2}$
of the elementary spaces $P_1,P_2$ we consider fixed given flat index maps
\begin{align*}
  \iota_{P_1}(\Lambda_{P_1}) &\to \mathbb{N}_0, &
  \iota_{P_2}(\Lambda_{P_2}) &\to \mathbb{N}_0.
\end{align*}
These are typically constructed by enumerating the grid entities
the basis functions are associated to.
Then the interior product space basis
\begin{align*}
  \Lambda_V = \Lambda_{P_2} \sqcup \Lambda_{P_2} \sqcup \Lambda_{P_2}
\end{align*}
together with the index map $\iota_{P_2}$ is a power node in the
sense of Definition~\ref{def:power_node}, while the tree root
\begin{align*}
 \Lambda_\text{TH}
  = \Lambda_V \sqcup \Lambda_{P_1}
\end{align*}
is a composite node.

The basis functions for the $k$-th component of the pressure
are denoted by
\begin{align*}
  v_{x_k,i} = \mathbf{e}_0 \otimes (\mathbf{e}_k \otimes \lambda^{P_2}_i)
\end{align*}
where $i=0,\dots,n_2-1$ for $n_2=|\Lambda_{P_2}|= \operatorname{dim} P_2$
while the basis functions for the pressure are denoted by
\begin{align*}
  p_{j} = \mathbf{e}_1 \otimes \lambda^{P_1}_j
\end{align*}
where $j=0,\dots,n_1-1$ for $n_1=|\Lambda_{P_1}|= \operatorname{dim} P_1$.

As two of the above given strategies can be used
for composite nodes, while all four can be applied to power nodes
we obtain eight different index maps for the Taylor--Hood basis
$\Lambda_{\text{TH}}$.
They are listed in Table~\ref{tab:th_indexing_variants}, where the label $X(Y)$
means that strategy $X$ is used for the outer product and strategy $Y$
for the inner product. For $X$ and $Y$ we use the abbreviations BL
(BlockedLexicographic), BI (BlockedInterleaved), FL (FlatLexicographic), an FI (FlatInterleaved).
Notice that the index-maps depicted in
Figure~\ref{fig:taylor_hood_index_tree} and Figure~\ref{fig:taylor_hood_index_blocked_tree}
are reproduced for the strategies
BL(BL) and BL(BI), respectively.

\begin{table}
\footnotesize
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c}
    & BL(BL)
    & BL(BI)
    & BL(FL)
    & BL(FI)
    & FL(BL)
    & FL(BI)
    & FL(FL)
    & FL(FI)
    \\
  \hline
  $v_{x_0,0}$
    & $(0,0,0)$
    & $(0,0,0)$
    & $(0,0)$
    & $(0,0+0)$
    & $(0,0)$
    & $(0,0)$
    & $(0)$
    & $(0+0)$
    \\
  $v_{x_0,1}$
    & $(0,0,1)$
    & $(0,1,0)$
    & $(0,1)$
    & $(0,3+0)$
    & $(0,1)$
    & $(1,0)$
    & $(1)$
    & $(3+0)$
    \\
  $v_{x_0,2}$
    & $(0,0,2)$
    & $(0,2,0)$
    & $(0,2)$
    & $(0,6+0)$
    & $(0,2)$
    & $(2,0)$
    & $(2)$
    & $(6+0)$
    \\
  $v_{x_0,3}$
    & $(0,0,3)$
    & $(0,3,0)$
    & $(0,3)$
    & $(0,9+0)$
    & $(0,3)$
    & $(3,0)$
    & $(3)$
    & $(9+0)$
    \\
  $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ &  $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$
  \\
%  $v_{x_0,n_2-1}$
%    & $(0,0,n_2-1)$
%    & $(0,n_2-1,0)$
%    & $(0,n_2-1)$
%    & $(0,3(n_2-1)+0)$
%    & $(0,n_2-1)$
%    & $(n_2-1,0)$
%    & $(n_2-1)$
%    & $(3(n_2-1)+0)$
%    \\
%  \hline
  $v_{x_1,0}$
    & $(0,1,0)$
    & $(0,0,1)$
    & $(0,n_2+0)$
    & $(0,0+1)$
    & $(1,0)$
    & $(0,1)$
    & $(n_2+0)$
    & $(0+1)$
    \\
  $v_{x_1,1}$
    & $(0,1,1)$
    & $(0,1,1)$
    & $(0,n_2+1)$
    & $(0,3+1)$
    & $(1,1)$
    & $(1,1)$
    & $(n_2+1)$
    & $(3+1)$
    \\
  $v_{x_1,2}$
    & $(0,1,2)$
    & $(0,2,1)$
    & $(0,n_2+2)$
    & $(0,6+1)$
    & $(1,2)$
    & $(2,1)$
    & $(n_2+2)$
    & $(6+1)$
    \\
  $v_{x_1,3}$
    & $(0,1,3)$
    & $(0,3,1)$
    & $(0,n_2+3)$
    & $(0,9+1)$
    & $(1,3)$
    & $(3,1)$
    & $(n_2+3)$
    & $(9+1)$
    \\
  $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ &  $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$
  \\
%  \hline
  $v_{x_2,0}$
    & $(0,2,0)$
    & $(0,0,2)$
    & $(0,2n_2+0)$
    & $(0,0+2)$
    & $(2,0)$
    & $(0,2)$
    & $(2n_2+0)$
    & $(0+2)$
    \\
  $v_{x_2,1}$
    & $(0,2,1)$
    & $(0,1,2)$
    & $(0,2n_2+1)$
    & $(0,3+2)$
    & $(2,1)$
    & $(1,2)$
    & $(2n_2+1)$
    & $(3+2)$
    \\
  $v_{x_2,2}$
    & $(0,2,2)$
    & $(0,2,2)$
    & $(0,2n_2+2)$
    & $(0,6+2)$
    & $(2,2)$
    & $(2,2)$
    & $(2n_2+2)$
    & $(6+2)$
    \\
  $v_{x_2,3}$
    & $(0,2,3)$
    & $(0,3,2)$
    & $(0,2n_2+3)$
    & $(0,9+2)$
    & $(2,3)$
    & $(3,2)$
    & $(2n_2+3)$
    & $(9+2)$
    \\
  $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ &  $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$
  \\
%  \hline
%  \hline
  $p_{0}$
    & $(1,0)$
    & $(1,0)$
    & $(1,0)$
    & $(1,0)$
    & $(3+0)$
    & $(n_2+0)$
    & $(3n_2+0)$
    & $(3n_2+0)$
    \\
  $p_{1}$
    & $(1,1)$
    & $(1,1)$
    & $(1,1)$
    & $(1,1)$
    & $(3+1)$
    & $(n_2+1)$
    & $(3n_2+1)$
    & $(3n_2+1)$
    \\
  $p_{2}$
    & $(1,2)$
    & $(1,2)$
    & $(1,2)$
    & $(1,2)$
    & $(3+2)$
    & $(n_2+2)$
    & $(3n_2+2)$
    & $(3n_2+2)$
    \\
  $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ &  $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$
  \\
  \hline
\end{tabular}
\end{center}
\caption{Different indexing strategies for the Taylor--Hood basis functions}
\label{tab:th_indexing_variants}
\end{table}



\subsection{Localization to single grid elements}
\label{sec:localization}

For the most part, access to finite element bases happens element by element.  It is therefore important
to consider the restrictions of bases to single grid elements.  In contrast to the previous sections
we now require that there is a finite element grid for the domain $\Omega$. For simplicity we will
assume that all bases consist of functions that are defined piecewise with respect to this grid,
but it is actually sufficient to require that the restrictions of all basis functions to elements
of the grid can be constructed cheaply.

Consider the restrictions of all basis functions $\lambda \in \Lambda$ of a given tree to a single fixed grid element $e$.
Of these restricted functions, we discard all those that are constant zero functions on $e$.
All others form the \emph{local basis} on $e$
\begin{equation*}
 \Lambda|_e
 \colonequals
 \{ \lambda|_e \; : \; \lambda \in \Lambda \}.
\end{equation*}
The local basis forms a tree that is isomorphic to the original function space basis tree,
with each global function space basis $\Lambda$ replaced by its local counterpart $\Lambda|_e$.

For a given index map $\iota$ of $\Lambda$,
this natural isomorphism from the global to the local tree
naturally induces a localized version of $\iota$ given by
\begin{align*}
  \iota|_e : \Lambda|_e &\to \mathcal{I}, &
  \iota|_e(\lambda_e) &\colonequals \iota(\lambda).
\end{align*}
This is the map that associates shape functions on a given grid element $e$ to
the multi-indices of the corresponding global basis functions.
Notice that the map $\iota|_e$ itself is not an index-map in the above given sense
since $\iota|_e(\Lambda|_e)$ is only a subset of the index tree $\iota(\Lambda)$,
and not always an index tree itself.

In order to index the basis functions in $\Lambda|_e$ efficiently we introduce
an additional local index map
\begin{align*}
  \iota^{\text{local}}_{\Lambda|_e}: \Lambda|_e \to \mathcal{N},
\end{align*}
such that $\iota^{\text{local}}_{\Lambda|_e}(\Lambda|_e)$ is an index tree.
The index $\iota^{\text{local}}_{\Lambda|_e}(\lambda|_e)$ is
called the \emph{local index} of $\lambda$ (with respect to $e$).
To distinguish it from the indices generated by $\iota$
we call $\iota(\lambda)$ the \emph{global index} of $\lambda$.
The local index is typically used to address the element stiffness matrix.
In principle, this indexing can use another non-flat index tree,
which does not have to coincide with the index tree for the global basis.
This means that the local index of a shape function can again be a multi-index, but the types,
lengths and orderings can be completely unrelated to the corresponding global indices.
This would allows to use nested types for element stiffness matrices and load vectors.
As explained in Chapter~\ref{sec:function_space_bases_implementation},
the \dunemodule{dune-functions} \emph{implementation} is fairly restrictive here,
and only allows flat local indices, i.e.,
$\iota^{\text{local}}_{\Lambda|_e}(\Lambda|_e) \subset \mathbb{N}_0.$

In addition, we introduce for each leaf local basis $\hat{\Lambda}|_e$
of the full local basis tree another local index map
\begin{align*}
  \iota^{\text{leaf-local}}_{\hat{\Lambda}|_e}: \hat{\Lambda}|_e \to \mathbb{N}_0.
\end{align*}
As there is no hierarchical structure involved, this index is simply a
natural number.
The index $\iota^{\text{leaf-local}}_{\hat{\Lambda}|_e}(\lambda|_e)$ is
called the \emph{leaf-local index} of $\lambda$ (with respect to $e$).

In an actual programming interface one typically accesses
basis functions by indices directly. We will later see that
in \dunemodule{dune-functions} the leaf-local index is the
shape function index of the \dunemodule{dune-localfunctions} module.
Hence the interface needs to implement the map
\begin{align*}
  \iota^{\text{leaf}\to\text{local}}_e \colonequals \iota^{\text{local}}_{\Lambda|_e} \circ (\iota^{\text{leaf-local}}_{\hat{\Lambda}|_e})^{-1}
\end{align*}
mapping leaf-local indices to local indices and
\begin{align*}
  \iota^{\text{local}\to\text{global}}_e \colonequals \iota|_e \circ (\iota^{\text{local}}_{\Lambda|_e})^{-1}
\end{align*}
mapping local indices to global multi-indices.


\section{Programmer interface for function space bases}
\label{sec:function_space_bases_implementation}

The design of the \dunemodule{dune-functions} interfaces for bases of discrete function spaces
follows the ideas of the previous section. The main interface concept are global basis objects
that represent trees of function space bases. These trees can be localized to individual elements
of the grid.  Such a localization gives you access to the (tree of) shape functions there,
and it provides the three types of shape-function indices.

\begin{figure}
 \begin{center}
  \begin{overpic}[width=\textwidth]{febasis_interface_schematic}
  \put(54.5,37){$\times$}
  \put(49,32){$\times$}
  \put(60,32){\tiny $P_1$}
  \put(44,27){\tiny $P_2$}
  \put(49,27){\tiny $P_2$}
  \put(54,27){\tiny $P_2$}
  \end{overpic}
 \end{center}
 \caption{Overview of the classes making up the interface to finite element space bases}
 \label{fig:febasis_interface_schematic}
\end{figure}

The user interface for localized function space bases is the \cpp{LocalView}.
It allows you to obtain the (tree of) local basis functions of that element, which in turn gives you access to all
shape functions, associations to element subentities, and local interpolation rules provided by
\dunemodule{dune-localfunctions}.
Furthermore it maps these shape functions to global degrees of freedom
by providing a map from element-local indices of these shape functions
to global (multi-)indices.
A local view is attached to a particular grid element by an
action called \emph{binding}.
The structure of the interface is visualized in
Figure~\ref{fig:febasis_interface_schematic}.
\todograeser{Remove LocalIndexSet from Figure~\ref{fig:febasis_interface_schematic}. Maybe redo this with tikz}

All header include paths
start with \cpp{dune/functions/}, and all code is contained in the namespace \cpp{Dune::Functions}.
Internally, \dunemodule{dune-functions} depends on the \dunemodule{dune-typetree} module,
which implements abstract compile-time tree data structures.
The global basis interface described below is not enforced by deriving
from specific base classes. Instead, \dunemodule{dune-functions} is based on
C++-style duck-typing~\cite{koenig_moo:2005}
i.e., any object providing the required
interface is a valid global basis.


\subsection*{Notation}

Throughout this text we will introduce programmer interfaces
by presenting the interface declaration, explaining
its meaning, and giving examples of its usage.
In order to distinguish interface declarations
from code examples, both are formatted differently.
Furthermore, implementation defined types, arguments,
and other omitted code fragments are highlighted.
Interface declarations are formatted like this:
\begin{lstlisting}[style=Interface]
// Declaration of the type T referring to an implementation-defined type
using T = @@<implementation defined>@@;

// Declaration of the function foo
T foo(int);

// Declaration of class Bar with implementation-defined constructor arguments
class Bar {
public:
  Bar(@@<args>@@);
};
\end{lstlisting}
An example for using this interface would be formatted like this:
\begin{lstlisting}[style=Example]
// Call foo() and store result
T t = foo(1);

// Construct an object of type Bar
auto bar = Bar(t, @@<more args>@@);
\end{lstlisting}


\subsection{User interface of a \texorpdfstring{\cpp{GlobalBasis}}{GlobalBasis}}
We start by describing the user interface of global bases.  Since we are discussing duck-typing interfaces,
all class names used below are generic. Trees of global bases are implemented by classes that implement
the \cpp{GlobalBasis} interface. In the following, we will call the generic such class \cpp{GlobalBasis}.
It can have an arbitrary number of template parameters.
All types, templates, and functions listed in the following
interface declaration are public members of
the generic class \cpp{GlobalBasis}.

In general each basis implementation may require its own specific data for construction.
Hence we do not enforce an argument list for this.
\begin{lstlisting}[style=Interface]
GlobalBasis(@@<implementation defined>@@);
\end{lstlisting}
The global basis represents a function space defined on a grid view, and access to
this view is provided by the
\begin{lstlisting}[style=Interface]
const GridView& gridView() const;
\end{lstlisting}
method. The corresponding type
is exported as \cpp{GridView}. If the grid view
was modified (e.g., by local grid refinement), the result of calling any
method of the basis is undefined until the basis was updated by
providing a new grid view by the method
\begin{lstlisting}[style=Interface]
void update(const GridView & gv);
\end{lstlisting}

Access to the basis functions and indices is available via the
local view interface.
\begin{lstlisting}[style=Interface]
using LocalView = @@<implementation defined>@@;
LocalView localView() const;
\end{lstlisting}
The \cpp{localView()} method returns a new object that implements the \cpp{LocalView} interface.
After binding this object to a
grid element from the respective grid view, it provides access
to the restriction of all basis functions whose support has a
nontrivial intersection with this element.
Additionally it allows to map the local indices
of all basis functions appearing in this local view to the
corresponding global multi-indices.
With a global basis given in an object called \cpp{basis},
the corresponding code is
\begin{lstlisting}[style=Example]
auto localView = basis.localView();
localView.bind(element);
\end{lstlisting}
where \cpp{element} is an element from the grid view.
For details on the
\cpp{LocalView} interface see below.

An additional group of methods provides information on the sizes of the bases
contained in the tree.
The total number of basis functions of the global basis is
exported via the \cpp{dimension()} method. However, since
the global indices are hierarchically structured multi-indices,
this information is generally not
sufficient to allocate hierarchical containers for storing,
e.g., coefficients with respect to all basis functions.
Therefore, the basis provides access to the structural
information of those multi-indices via the \cpp{size(SizePrefix)}
method. The given prefix takes the form of a multi-index itself.
If $\mathcal{I}$ is the set of all global multi-indices of the
basis and $P \in \mathcal{N}$ is a prefix for this set,
i.e. there is a $(P,\dots) \in \mathcal{I}$, then
\cpp{size(P)} returns the size $\operatorname{deg}^+_{\mathcal{I}}[P]$ of
$\mathcal{I}$ relative to $P$ defined according to \eqref{eq:prefix_size}.
%For a prefix $(p_1,\dots,p_k)$ the method returns the maximal value $q$ such that there
%is a global index of the form $(p_1,\dots,p_k,q-1,\dots)$.
If $P$ is not a prefix for $\mathcal{I}$ the result is undefined.
If $P \in \mathcal{I}$, i.e., the prefix is itself one of the multi-indices
then the result is zero.
In any case the result corresponds to the number of direct children
of the node $P$ in the index tree.
For convenience there is also a method \cpp{size()} returning the same
value as the method with an empty prefix, i.e., \cpp{size(\{\})}.
For a scalar basis, this method again returns the number of basis functions.

Since prefixes may have variable size, it is guaranteed that the type \cpp{SizePrefix}
is always a \cpp{Dune::ReservedVector<size\_type,k>} where \cpp{k}
is as least as large as the maximal length of a multi-index. The result
type of all size-related methods is exported as \cpp{size\_type}.

The typo of used global multi-indices is exported as \cpp{MultiIndex}.
The interface of this type is discussed later.

\begin{lstlisting}[style=Interface]
using size_type = @@<implementation defined>@@;
using SizePrefix = @@<implementation defined>@@;
using MultiIndex = @@<implementation defined>@@;
size_type dimension() const;
size_type size() const;
size_type size(const SizePrefix& prefix) const;
\end{lstlisting}



To statically check for the interface,
\dunemodule{dune-functions} provides a concept definition of a global
basis which can, e.g., be used to check validity in a static assertion.

\begin{lstlisting}[style=Example]
// The global basis concept for given grid view
using GlobalBasisConcept = Dune::Functions::Concept::GlobalBasis<GridView>;

// Check if Basis models the concept
static_assert(Dune::models<GlobalBasisConcept, Basis>(),
  "Basis does not model the global basis concept.")
\end{lstlisting}

\subsection{User interface of a \texorpdfstring{\cpp{LocalView}}{LocalView}}

The \cpp{LocalView} concept represents the localization of a basis tree to a single element.
\cpp{LocalView} objects are returned by the method \cpp{GlobalBasis::localView()}.
All types, templates, and functions listed in the following
interface declaration are public members of
the generic class \cpp{LocalView}.
There is no way to construct such objects directly.
The global basis of type \cpp{GlobalBasis}
is known by the \cpp{LocalView} object, and exported by the \cpp{globalBasis()} method.
\begin{lstlisting}[style=Interface]
using GlobalBasis = @@<implementation defined>@@;
const GlobalBasis& globalBasis() const;
\end{lstlisting}

A local view provides access to all basis
functions whose support has nontrivial intersection with
a given element (the \emph{local basis functions}).
To achieve this, the local view must
first be bound to this element by calling
\begin{lstlisting}[style=Interface]
using GridView = typename GlobalBasis::GridView;
using Element = typename GridView::template Codim<0>::Entity;
void bind(const Element& e);
\end{lstlisting}
This call may incorporate expensive computations needed to
setup the those local basis functions
and to pre-compute their global indices
which are stores in an internal cache.
The local view can be
bound to another element by calling this method again.
To set the local view to unbound state again, you
can call the
\begin{lstlisting}[style=Interface]
void unbind();
\end{lstlisting}
method.
Notice that the local view will store a copy of the bound
element that is accessible via \cpp{element()}.
\begin{lstlisting}[style=Interface]
using Element = typename GridView::template Codim<0>::Entity;
const Element& element() const;
\end{lstlisting}

The total number of basis functions associated to the
local view at the currently bound element is returned
by \cpp{size()}. The result of calling this method in
unbound state is undefined.
To allow preallocation of buffers for local functions
the \cpp{maxSize()} method returns the maximum of the
\cpp{size()} method for all elements in the grid view
associated to the global basis. This can be called in
unbound state.

\begin{lstlisting}[style=Interface]
using size_type = typename GlobalBasis::size_type;
size_type size() const;
size_type maxSize() const;
\end{lstlisting}

Access to the actual local basis functions is provided
by the \cpp{tree()} method returning a reference to a
\cpp{Tree} object. This encapsulates the basis functions
in a hierarchical tree structure to also represent structured
function spaces.
While the tree  itself can be queried in unbound state,
the local view must be bound in order to use most of the
trees methods.
A detailed discussion of the interface of the tree object is
given below.

\begin{lstlisting}[style=Interface]
using Tree = @@<implementation defined>@@;
const Tree& tree() const;
\end{lstlisting}

For any of the local basis functions in the local ansatz tree
accessible by \cpp{tree()} the global
multi-index of type \cpp{MultiIndex}
is provided by the \cpp{index(size\_type)} method.
The argument for this method is the local
index of the basis function within the tree as
returned by the \cpp{node.localIndex(k)}
method, where \cpp{node} is a leaf node of the
tree provided by \cpp{tree()} and \cpp{k}
is the number of the shape function within the corresponding
local finite element (see below).
Hence the method \cpp{index(size\_type)}
implements the map $\iota^{\text{local}\to\text{global}}_e$
with bound-to element $e$
introduced in Section~\ref{sec:localization}
which maps local indices to global multi-indices.
Accessing the same global index multiple times
is cheap, because global indices are pre-computed
and cached during \cpp{bind(Element)}.
The result of calling \cpp{index(size\_type)} in
unbound state is undefined.

\begin{lstlisting}[style=Interface]
using MultiIndex = @@<implementation defined>@@;
MultiIndex index(size_type i) const;
\end{lstlisting}



\subsection{User interface of a local ansatz \texorpdfstring{\cpp{Tree}}{Tree}}
The local view provides access to all local basis functions
by exporting a \cpp{Tree} object. This implements a tree
data structure using the foundation classes of the
\dunemodule{dune-typetree} library, where the actual local basis
functions for each factor are associated to a leaf node
in the tree. As a consequence the interface of leaf nodes
provides some additional features.
Both node types are not meant to be constructed by the
user so there is no constructor in the interface.
First we describe the interface shared by interior
and leaf nodes.

The \cpp{size()} method returns the total number of
local basis functions within the subtree rooted at the
present node. For each of these local basis functions
the \cpp{localIndex(size\_type)} method returns a unique
local index within all local basis functions associated to the full
tree.
The argument to this method is the lexicographic
index of the local basis functions within the subtree
and the result is the lexicographic index within the full
tree.
Hence the local indices of all basis functions
within this subtree form a consecutive range.
The result of these methods is undefined if the
local view containing the tree is in unbound state.
All these indices are of type \cpp{size\_type}.

If the node corresponds to a leaf,
then the method \cpp{localIndex(size\_type)}
implements the map $\iota^{\text{leaf}\to\text{local}}_e$
with bound-to element $e$
introduced in Section~\ref{sec:localization}
which maps leaf-local to local indices.

\begin{lstlisting}[style=Interface]
class BasisNode
{
public:
using size_type = @@<implementation defined>@@;
size_type size() const;
size_type localIndex(size_type i) const;
\end{lstlisting}

For some computations it is important to identify
individual nodes in the tree. To this end the node
exports its path with respect to the full tree root
via the \cpp{treePath()} method.
The result is a multi-index
implemented by the \cpp{Dune::TypeTree::HybridTreePath}
class defined in the \dunemodule{dune-typetree} module.
On the other hand any interior node allows to access
its children using the \cpp{child()} method.
The path to the desired child can either be passed
as a \cpp{Dune::TypeTree::HybridTreePath} object
or as a sequence of indices. Indices referring
to the child of a power node can be passed as
an integral value, e.g., as \cpp{std::size_t}.
Indices referring to children of a composite node
have to be passed statically as \cpp{Dune::index_constant<i>}.
For convenience global constants \cpp{_0},\cpp{_1}, \dots
of this type are implemented in the \cpp{Dune::Indices}
namespace.
If data needs to be attached to nodes,
the \cpp{treeIndex()} can be used. The latter returns
the lexicographic index of the node within the full
tree in a fixed type for all nodes.
These methods can also be used if the local view containing
the tree is in unbound state.

\begin{lstlisting}[style=Interface]
using TreePath = @@<implementation defined>@@;
const TreePath& treePath() const;
size_type treeIndex() const;

// The following methods do only exist for interior nodes
template<class... ChildIndices>
auto child(ChildIndices... childIndices);

template<class ChildTreePath>
auto child(ChildTreePath childTreePath);
}; // end BasisNode
\end{lstlisting}

Leaf nodes share the same interface as interior
nodes. Additionally they provide access to the
element which the local view and thus the tree is bound
to via the \cpp{element()} method. Probably most important
is the \cpp{finiteElement()} method that gives access
to the local finite element. The finite element
itself provides access to the local basis functions
by the finite element interface defined in the
\dunemodule{dune-localfunctions} module.
It is important to note that the lexicographic
index of a basis function in a leaf node coincides
with its number in the local finite element.

\begin{lstlisting}[style=Interface]
class LeafBasisNode
{
public:
// interface common with interior nodes
using size_type = @@<implementation defined>@@;
size_type size() const;
size_type localIndex(size_type i) const;
using TreePath = @@<implementation defined>@@;
const TreePath& treePath() const;
size_type treeIndex() const;

using Element = @@<implementation defined>@@;
using FiniteElement = @@<implementation defined>@@;
const Element& element() const = 0;
const FiniteElement& finiteElement() const = 0;
}; // end LeafBasisNode
\end{lstlisting}



\subsection{Using the localized interface}
\label{sec:localized_interface}

We now give a short example on how to use the interface
to compute global indices for local basis functions
of a given \cpp{globalBasis} at a given \cpp{element}.
If we want to compute the global index of the \cpp{i}-th
local basis function in the finite element attached to
a leaf node this can be done by the following snippet.

\begin{lstlisting}[style=Example]
// create a LocalView
auto localView = basis.localView();

// bind the LocalView to the element
localView.bind(element);

// obtain the basis tree
const auto& node = localView.tree();

// compute local index of local basis function within the tree
auto localIndex = node.localIndex(i);

// compute global index of local basis function
auto globalIndex = localView.index(localIndex);
\end{lstlisting}

Here we assumed that we do not have a nested local ansatz tree
such that the \cpp{tree()} method directly returns a \cpp{LeafBasisNode}.
In this case \cpp{localIndex} coincides with \cpp{i}.
In the more general case of a nontrivial product space
we must first retrieve the leaf node corresponding to
the desired factor in the product space. This can be done
using the tree path for this node. If, for example,
we have a Taylor-Hood element, where the first
child in the tree corresponds to the velocity,
which itself has $dim$ children for the velocity
components, the leaf node for the second velocity
component can be obtained by the following.

\begin{lstlisting}[style=Example]
// import namespace with index constants
using namespace Indices;

// obtain the leaf node for 2nd component of the velocity tree
const auto& node = localView.tree().child(_0, 1);
\end{lstlisting}

Notice that we used the index constants \cpp{\_0}, \dots{}
from the namespace \cpp{Dune::Indices}
to address the velocity node because the
tree root is a composite node whose child nodes
for velocity and pressure are of different type.
The same result can be achieved by the following
slightly more verbose code.

\begin{lstlisting}[style=Example]
// generate tree path for 2nd component of the velocity tree
auto treePath = TypeTree::treePath(_0, 1);

// obtain the desired leaf node in the basis tree using the child method
const auto& node = localView.tree().child(treePath);

// obtain the desired leaf node in the basis tree using the global child function
const auto& node = TypeTree::child(localView.tree(), treePath);
\end{lstlisting}



\subsection{Multi-indices}
Multi-indices are used in several places in \dunemodule{dune-functions}.
On the one hand, the global indices used to identify individual
basis functions of a function space bases are in general multi-indices.
On the other hand, the nodes in a tree of local function space bases
can be identified by the multi-index encoding the path from the root
of the tree.

While, in some cases, the global multi-index used to identify
basis functions is flat (i.e. contains a single entry)
and should thus for convenience behave like a simple dynamic number,
the multi-indices needed to access the nodes in a tree often must be
static compile type values.
To serve these different needs, \dunemodule{dune-functions} uses several
types to represent multi-indices. However, all implement
a common interface which is a slimmed down version of a random
access container consisting of two member functions.

\begin{lstlisting}[style=Interface]
auto operator[](std::size_t) const;
std::size_t size() const;
\end{lstlisting}

The \cpp{size()} returns the size of the multi-index
and \cpp{operator[](std::size_t)} allows to access
each entry by its number. Since multi-indices are
in most cases not changed, the general interface
is \cpp{const} and does not allow modification of the
entries.
Additionally to this general interface, some implementations
provide further methods or guarantees. In the following we will
give an overview of the types used to represent multi-indices
in \dunemodule{dune-functions}. The type used to represent
the raw entries of multi-indices is in general selected to
be \cpp{std::size_t}.

Multi-indices with run-time dynamic size are represented
by the class
\begin{lstlisting}[style=Interface]
template <class T, int k>
class ReservedVector;
\end{lstlisting}
from the \dunemodule{dune-common} module which is parameterized
by the entry type \cpp{T} and the maximal size \cpp{k}.
This allows for a dynamic size up to \cpp{k} entries
in contrast to a statically sized \cpp{std::array<T,k>}.
This feature is needed, if the multi-indices of the
function space basis are non-uniform, i.e., multi-indices
of different basis functions may have a different size.
In contrast to a fully dynamic vector implementation
like \cpp{std::vector<T>} this class uses a fixed size
buffer member of size \cpp{k} to store its entries.
This has the advantage that no dynamic memory management
is needed making the implementation much more efficient.
Furthermore, the global multi-indices typically have
a small number of digits only with a known upper bound.
Hence the overhead of always using a buffer of size \cpp{k}
although the number of entries might be smaller will often be small.
Unless it is known at compile time, that the used multi-indices
are flat, \cpp{ReservedVector<std::size_t,k>} with appropriate
\cpp{k} is used to represent the global multi-indices
provided by a function space basis.


\todograeser{General multi-indices, dynamic multi-indices, hybrid multi-indices, implementations}

The type of global multi-indices is hard-wired by \dunemodule{dune-functions}.  Generally, multi-indices
will be objects of type
\begin{lstlisting}
template <class T, int n>
class ReservedVector;
\end{lstlisting}
This is a general container class, provided by \dunemodule{dune-common} in the file
\file{dune/common/reservedvector.hh}.  It behaves like a \cpp{std::vector}, i.e., it is a
random-access container with dynamically adjustable size.  The difference to a \cpp{std::vector}
is that a \cpp{ReservedVector} stores its data on the operating system stack, rather than on
the heap.  This allows for much more efficient container construction, destruction, and data access.
However, as stack space is limited, \cpp{ReservedVector} objects can only be used for small amounts
of data. The second template parameter specifies the amount of memory to reserve on the stack
(in units of data items \cpp{T}). If the actual container size exceeds that number, the resulting
behavior is undefined.
\todosander{Erklären dass der Zahlentype \cpp{T} von außen gesteuert werden kann.}

It has to be noted that while the trees of global and local basis functions is encoded statically
in C++ type information, the index tree, i.e., the set of multi-indices use to label global
degrees of freedom is a pure run-time construct.  This can be inconvenient when using multi-indices
to access containers such as \cpp{std::tuple} or \cpp{MultiTypeBlockVector} from the \dunemodule{dune-istl}
module.
\todosander{Begründe diese Entscheidung.}

If the basis is indexed with a flat index, i.e., a multi-index with only a single digit,
then using a \cpp{ReservedVector} can be a bit cumbersome (besides being inefficient, because
each \cpp{ReservedVector} object stores its size as a run-time value).  Morally, flat multi-indices
are simply natural numbers.  However, if \cpp{i} is \cpp{ReservedVector} of length~1,
using it to access the corresponding entry of a \cpp{std::vector} called \cpp{vec} has to be
written as
\begin{lstlisting}
auto value = vec[i[0]];
\end{lstlisting}
To allow the more intuitive syntax
\begin{lstlisting}
auto value = vec[i];
\end{lstlisting}
\dunemodule{dune-functions} switches away from the \cpp{ReservedVector} implementation if the index
of a basis tree is flat.  In that case, indices are stored as objects of type \cpp{FlatMultiIndex}.
These objects behave like objects of type \cpp{std::array<T,1>}.  Additionally, they allow to cast
theiry content to \cpp{T&}.  Therefore, objects of type \cpp{FlatMultiIndex} can be directly used
like number types, and like multi-index types as well.
\todosander{Wenn man das hier liest drängt sich die Frage auf warum man nicht allgemeiner für
uniforme Multi-Indizes auf \cpp{std::array} wechseln kann (ohne den Cast-Operator, natürlich).
Da Multi-Indizes ja vermutlich häufig kopiert werden, möchte man die Länge ja wirklich nur
dabei haben wenn man sie wirklich braucht.}


\subsubsection{HybridTreePath}

\begin{figure}
 \begin{center}
  \missingfigure{Example tree paths}
 \end{center}
 \caption{Example tree paths}
 \label{fig:dune_functions:tree_paths}
\end{figure}

As a data structure, a \cpp{HybridTreePath} object is a finite sequence of integers.
Starting from the tree root, each integer corresponds to a tree node, and the number specifies which
subtree of that node to select (Figure~\ref{fig:dune_functions:tree_paths}).
For an example, in the Taylor--Hood tree, the integer sequence $(0)$ will select the velocity subtree,
$(1)$ will select the pressure subtree, and $(0,i)$ will select the $i$-th velocity component for $i=0,\dots,d-1$.
The empty sequence $()$ represents the entire tree.

In the implementation of \cpp{HybridTreePath}, there are two different integer types.  Remember that there are
two different types of nodes in a finite element basis tree: \cpp{power} nodes, where all direct subtrees
are identical, and \cpp{composite} nodes, where the subtrees may differ.
The subtrees of a \cpp{PowerBasis} can be addressed by a regular integer,
but for the children of a \cpp{CompositeBasis}, the static indices \cpp{_0}, \cpp{_1}, \cpp{_2}, etc.\
from \file{dune/common/indices.hh} were necessary (from the namespace \cpp{Dune::Indices}, these are names
for the types \cpp{std::integral_constant<std::size_t,0>} etc.).

To accomodate both ways to index subtrees, a \cpp{HybridTreePath} can combine both types of entries.
The constructor call
\begin{lstlisting}
auto path = TypeTree::treePath(_0);
\end{lstlisting}
will select the velocity subtree of a Taylor--Hood basis, while
\begin{lstlisting}
auto path = TypeTree::treePath(_1);
\end{lstlisting}
will select the pressure tree.
\begin{lstlisting}
auto path = TypeTree::treePath(_0,0);
\end{lstlisting}
will select the $0$-th velocity component, and
\begin{lstlisting}
auto path = TypeTree::treePath();
\end{lstlisting}
will select the entire tree.  Note how the tree path to the $0$-th velocity component combines a compile-time
index with a run-time index.  In a sense, a \cpp{HybridTreePath} is a combination between a \cpp{std::array}
and a \cpp{std::integer_sequence}.







\section{Constructing trees of function space bases}

There are various ways to construct finite element bases in \dunemodule{dune-functions}.
A set of standard bases is provided directly.  These can then be combined to form trees.
Conversely, subtrees can be extracted, and they act like complete bases in their own right.

\subsection{Basis implementations provided by \texorpdfstring{\dunemodule{dune-functions}}{dune-functions}}
\label{subsec:available_bases}

The \dunemodule{dune-functions} module contains a collection of standard finite element bases.
These can be directly used in finite element simulation codes. At the time of writing there is:

\begin{itemize}
 \item \cpp{LagrangeBasis}: Lagrangian bases of order $k$, where $k$ is a compile-time parameter.
   For $k\le 2$, this implementation works on all kinds of conforming grids, including grids with more
   than one element type.  At the time of writing, higher-order spaces are implemented only partially.
   Check the online class documentation for the current status.

 \item \cpp{LagrangeDGBasis}: Implements a $k$-th order Discontinuous-Galerkin basis with Lagrange shape functions.
   Therefore, this basis also
   works well on non-conforming grids.  The polynomial order is again a compile-time constant.

 \item \cpp{RannacherTurekBasis}: An $H^1$-nonconforming scalar basis, which adapts the idea
   of the Crouzeix--Raviart basis to cube grids~\cite{rannacher_turek:1992}.

 \item \cpp{BSplineBasis}:  Implements a $B$-Spline basis on a structured, axis-aligned grid as described,
   e.g., in~\cite{cottrell_hughes_bazilevs:2009}.  Arbitrary orders, dimensions, and knot vectors are supported,
   allowing, e.g., to work with $C^1$ elements for fourth-order differential equations.

   Each \cpp{BSplineBasis} object implements a basis on a single patch, and the grid must correspond to this
   patch. For this to work, several restrictions apply for the grid.  It must be structured and axis-aligned,
   and consist of (hyper-)cube elements only.  Further, the element indices must be lexicographic and
   increase from the lower left to the upper right domain corner.  The element spacing must match the knot spans.
   Unfortunately, not all these requirements can be checked for by the basis, so users have to be a bit
   careful.  Using a \cpp{YaspGrid} object works well.

   Unlike in standard finite element bases, in a B-spline basis the basis functions cannot be associated
   to grid entities such as vertices, edges, or elements.  The interface nevertheless mandates that a
   \cpp{LocalCoefficient} object must be available on each element, that assigns shape functions
   to faces of the reference elements. For the \cpp{BSplineBasis}, the behavior of this
   object is undefined.

 \item \cpp{TaylorHoodBasis}:
   An implementation of a Taylor--Hood basis.
   This is a simple implementation example of a basis with a non-trivial tree.
   Notice that non-trivial product bases like a Taylor--Hood basis
   can be easily constructed in a generic way. This approach is described
   in Chapter~\ref{sec:composed_bases} and the preferred way to construct
   a Taylor--Hood basis.
\end{itemize}

The bases listed above all have the property, that the shape functions provided by
\cpp{tree.finiteElement()} are implemented in terms of local element coordinates
for the domain. That is, if the bound-to grid element $e$ is obtained by the transformation
$\Phi_e:R \to e$ from the reference element $R$, then the implemented localized shape function
representing the restriction of the basis function $\lambda$ to the
element $e$ is given by $\hat{\lambda}|_e = \lambda\circ\Phi_e$.

Non-affine finite elements may require additional transformations such that it is
not reasonable to export localized shape functions satisfying the above given
invariance. In this case the interpretation of the shape functions requires some
implementation defined transformations. This is the case for the following global
bases implementations, that otherwise behave like any other basis.

\begin{itemize}
 \item \cpp{RaviartThomasBasis}: The standard Raviart--Thomas basis for problems in
  $H(\text{div})$~\cite{boffi_brezzi_fortin:2013}.  Available for different orders and element types.
  The shape functions exported by \cpp{tree.finiteElement()} do not include the Piola-transformation.

 \item \cpp{BrezziDouglasMariniBasis}: The standard Brezzi--Douglas--Marini basis, which is an
  alternative basis for $H(\text{div})$-conforming problems~\cite{boffi_brezzi_fortin:2013}.
  The shape functions exported by \cpp{tree.finiteElement()} do not include the Piola-transformation.
  \todograeser{Is this correct for BDM?}
\end{itemize}

For a detailed discussion of the template parameters and constructor arguments
of the basis implementations listed above we refer to the class documentation.


\subsection{Combining bases into trees}
\label{sec:composed_bases}

The basis implementations of the previous section can be combined by multiplication to form new bases.
This produces the tree structures described in Section~\ref{sec:finite_element_trees}.
The code for this resides in the \cpp{BasisFactory} namespace, which is a nested namespace
within \cpp{Dune::Functions::}. Therefore, the examples of this section need a
\begin{lstlisting}[style=Example]
using namespace Dune::Functions::BasisFactory;
\end{lstlisting}
to compile.

The methods to combine bases into trees do not operate on the basis classes of the previous section
directly.  Rather, they combine so-called \emph{pre-bases}, of which there is one for each basis.
The reason for this is
that it is technically very challenging to combine the actual user-visible basis types in a
tree hierarchy that itself again implements the interface of a hierarchical function space basis.
Therefore, the multiplication operators are applied to pre-basis objects, and return pre-basis
objects of the resulting tree.
The pre-basis of the final basis tree can then be turned into an actual basis.

Since all pre-bases in the product pre-basis have to know some common information
like, e.g., the grid view, doing this hierarchic construction
manually is verbose and error prone. As a more user friendly and safer solution
a global basis can be constructed by a call to
\begin{lstlisting}[style=Interface]
template <class GridView, class PreBasisFactory>
auto makeBasis(const GridView& gridView, PreBasisFactory&& preBasisFactory);
\end{lstlisting}
The pre-basis-factory argument encodes the hierarchic product.
The involved pre-bases are constructed automatically by the
\cpp{makeBasis()} function in a consistent way.
This also determines a suitable multi-index type automatically
which, otherwise, would have to be done by the user.

In the simple-most case, the tree consists of a single basis.
As a convention, for each implemented global basis
\cpp{FooBarBasis} there is a function \cpp{BasisFactory::fooBar()}
creating a suitable pre-basis-factory object which
stores all basis-specific information.
This function is defined in the same header file.
That means that in particular you can write
\todosander{Darf nicht mehr \cpp{BasisType} benutzen!}
\begin{lstlisting}[style=Example]
auto raviartThomasBasis = makeBasis(gridView, raviartThomas<k, GeometryType::BasicType::cube>());
\end{lstlisting}
to obtain a Raviart--Thomas basis for the given grid view.
Notice that the \cpp{raviartThomas()} function does not need
the grid view as parameter.
This is equivalent to constructing
the basis directly:
\begin{lstlisting}[style=Example]
RaviartThomasBasis<GridView,k,GeometryType::BasicType::cube> raviartThomasBasis;
\end{lstlisting}
This example shows another convention: The template and constructor parameters
of the \cpp{FooBarBasis} are given in the same order as the template
parameters and arguments of the \cpp{BasisFactory::fooBar()} function,
despite the fact that the former has the grid view type and object prepended.

The pre-basis combining several bases in a product is called \cpp{CompositePreBasis}
defined in the header \file{dune/functions/functionspacebases/compositebasis.hh}.
Analogously to the above description, a corresponding pre-basis-factory
can be constructed using a global function
with the signature
\begin{lstlisting}[style=Interface]
template <class... ChildPreBasisFactory>
auto composite(ChildPreBasisFactory&&... childPreBasisFactory);
\end{lstlisting}
%\begin{lstlisting}[style=Interface]
%template <class... ChildPreBasisFactory, class IndexMergingStrategy>
%auto composite(ChildPreBasisFactory&&... childPreBasisFactory, IndexMergingStrategy indexMergingStrategy);
%\end{lstlisting}
contained in the namespace  \cpp{BasisFactory::}.
The method has an unspecified number of arguments, of unspecified type.
The arguments are expected to be pre-basis-factory objects themselves.
This can either be plain pre-basis-factories constructed by, e.g.,
\cpp{lagrange<1>()} or \cpp{raviartThomas<k, GeometryType::BasicType::cube>()},
or composite- or power-pre-basis-factories constructed by \cpp{composite()}
or \cpp{power()} (see below), respectively.

As an example, to combine a Raviart--Thomas basis with a zero-order Lagrange basis (for solving
the mixed formulation of the Poisson equation, say), the appropriate call is
\begin{lstlisting}[style=Example]
auto mixedBasis = makeBasis(
  gridView,
  composite(
    raviartThomas<0, GeometryType::BasicType::cube>(),
    lagrange<0>()
  ));
\end{lstlisting}
Combining three copies of a first order Lagrange basis for a displacement field in elasticity theory is
\begin{lstlisting}[style=Example]
auto displacementBasis = makeBasis(
  gridView,
  composite(
    lagrange<1>(),
    lagrange<1>(),
    lagrange<1>()
  ));
\end{lstlisting}
The examples produce the trees shown in Figure~\ref{fig:example_composite_bases}.

\begin{figure}
    \begin{center}
        \begin{tikzpicture}[
                level/.style={
                    sibling distance = (3-#1)*0.3cm + 1cm,
                    level distance = 1.5cm
                }
            ]
            \node [treenode] {$\Lambda_{RT} \sqcup \Lambda_{P_0}$}
                child{ node [treenode] {$\Lambda_{RT}$} }
                child{ node [treenode] {$\Lambda_{P_0}$} };
        \end{tikzpicture}
        %
        \hspace{0.15\textwidth}
        %
        \begin{tikzpicture}[
                level/.style={
                    sibling distance = (3-#1)*0.3cm + 1cm,
                    level distance = 1.5cm
                }
            ]
            \node [treenode] {$\Lambda_{P_1} \sqcup \Lambda_{P_1} \sqcup \Lambda_{P_1}$}
                child{ node [treenode] {$\Lambda_{P_1}$} }
                child{ node [treenode] {$\Lambda_{P_1}$} }
                child{ node [treenode] {$\Lambda_{P_1}$} };
        \end{tikzpicture}
    \end{center}
    \caption{Example composite bases}
    \label{fig:example_composite_bases}
\end{figure}


That last example is not as elegant as it could be.  First of all, it is inconvenient and unnecessarily
wordy to list the same scalar Lagrange basis three times.  Secondly, the required number may depend on
a compile-time parameter.
Finally, the implementation can benefit from the explicit knowledge that
all children are equal in terms of efficiency.
For these reasons, \dunemodule{dune-functions}
offers a second way to combine bases: The \cpp{PowerPreBasis} with a
corresponding pre-basis-factory to be constructed with \cpp{BasisFactory::power()}. 
The interface is again a single method
\begin{lstlisting}[style=Interface]
template<std::size_t k, class ChildPreBasisFactory>
auto power(ChildPreBasisFactory&& childPreBasisFactory)
\end{lstlisting}
provided in the file \file{dune/functions/functionspacebases/powerbasis.hh}.
It combines \cpp{k} copies of a subtree of type \cpp{ChildPreBasisFactory} in a new tree.  Therefore, the
displacement vector field basis from above is more easily written as
\begin{lstlisting}[style=Example]
auto displacementBasis = makeBasis(
  gridView,
  power<3>(
    lagrange<1>()
  ));
\end{lstlisting}
Since \cpp{composite()} and \cpp{power()} create pre-basis-factories themselves,
all these techniques can be combined. To obtain the \cpp{p}-th order Taylor--Hood basis,
write
\begin{lstlisting}[style=Example]
auto taylorHoodBasis = makeBasis(
  gridView,
  composite(
    power<dim>(
      lagrange<p+1>()),
    lagrange<p>()
  ));
\end{lstlisting}
The call to \cpp{power} produces the \cpp{dim}-component velocity basis of order \cpp{p+1},
and the call to \cpp{composite} combines this with a \cpp{p}-th order Lagrange basis for the pressure.
Note that this is the preferred way to construct a Taylor--Hood basis in contrast to
\begin{lstlisting}[style=Example]
auto taylorHoodBasis1 = makeBasis(gridView, taylorHood());
auto taylorHoodBasis2 = TaylorHoodBasis<GridView>(gridView);
\end{lstlisting}
since these variants mainly exist as implementation example (see the discussion on \cpp{TaylorHoodBasis} in Section~\ref{subsec:available_bases}).

The previous discussion has left out the question of how the degrees of freedom in the combined tree
are numbered.  In Section~\ref{sec:index_trees} it was explained how the indices
of the degrees of freedom form a separate tree by their multi-index structure, and how this tree
is constructed from the basis tree by a set of rules.  First of all, each of the bases of
Section~\ref{subsec:available_bases} implements a numbering of its degrees of freedom,
and generally these numberings cannot be changed.
To select a degree of freedom numbering for a nontrivial basis,
each call to \cpp{composite} or \cpp{power} can be augmented by an additional
flag indicating an \cpp{IndexMergingStrategy}. The four implemented strategies are
\begin{itemize}
  \item
    \cpp{BlockedLexicographic}
  \item
    \cpp{BlockedInterleaved}
  \item
    \cpp{FlatLexicographic}
  \item
    \cpp{FlatInterleaved}
\end{itemize}
and have been described in Section~\ref{sec:index_strategies}.
For each strategy \cpp{FooBar} there is a function \cpp{BasisFactory::fooBar()} creating
the flag in the header \file{functionspacebases/basistags.hh}.

For example, a Taylor--Hood basis with the indexing listed in the
second column (labeled BL(BI)) of Table~\ref{tab:th_indexing_variants} can be created using
\begin{lstlisting}[style=Example]
auto taylorHoodBasis = makeBasis(
  gridView,
  composite(
    power<dim>(
      lagrange<p+1>(),
      blockedInterleaved()),
    lagrange<p>(),
    blockedLexicographic()
  ));
\end{lstlisting}
This will lead to multi-indices of length three and two
for velocity and pressure degrees of freedom, respectively.
The same ordering of basis functions with a uniform indexing scheme
with multi-index length two (column four labeled BL(FI) in Table~\ref{tab:th_indexing_variants}) is obtained using
\begin{lstlisting}[style=Example]
auto taylorHoodBasis = makeBasis(
  gridView,
  composite(
    power<dim>(
      lagrange<p+1>(),
      flatInterleaved()),
    lagrange<p>(),
    blockedLexicographic()
  ));
\end{lstlisting}
Finally, of flat indexing scheme still preserving the same ordering
(column eight labeled FL(FI) in Table~\ref{tab:th_indexing_variants})
obtained by
\begin{lstlisting}[style=Example]
auto taylorHoodBasis = makeBasis(
  gridView,
  composite(
    power<dim>(
      lagrange<p+1>(),
      flatInterleaved()),
    lagrange<p>(),
    flatLexicographic()
  ));
\end{lstlisting}



\section{Treating subtrees as separate bases}
\todograeser{Update, \cpp{DiscreteGlobalBasisFunction}, \cpp{interpolate()}}

Additionally to the concept of a global basis as defined here, there
is also the concept of a so called \cpp{SubspaceBasis} reflecting
the basis of the subtree only spanned by those basis functions
associated to a subtree of the local ansatz tree of the so-called
root basis.
The interface of \cpp{SubspaceBasis} mostly coincides with
the interface of a global basis. Additionally to the \cpp{GlobalBasis}
interface described above the \cpp{SubspaceBasis} provides
information about the embedding into the global basis.
Notice that a \cpp{SubspaceBasis} differs from a classical
global basis, because the global multi-indices are the
same as the ones of the root basis and thus in general
not consecutive. As a consequence those multi-indices
allow to access containers storing coefficients for the
full root basis.

\begin{lstlisting}[style=Interface]
using PrefixPath = @@<implementation defined>@@;
const @@<implementation defined>@@& rootBasis() const
const PrefixPath& prefixPath() const
\end{lstlisting}

The method \cpp{rootBasis()} provides access to the root basis.
Additionally the \cpp{prefixPath()} method returns the
path of the subtree associated to the \cpp{SubspaceBasis}
with the full tree.

For convenience a global basis behaves like a trivial \cpp{SubspaceBasis},
i.e., it contains the method \cpp{rootBasis()} returning the basis itself
and \cpp{prefixPath()} returns an empty tree-path of the
implementation defined type \cpp{PrefixPath}.

A \cpp{SubspaceBasis} can be created using a global
factory function providing the root basis and the path
to the desired subtree. The path can either be passed
as a single tree path object (see Section~\ref{}) or
as a sequence of individual indices.

\begin{lstlisting}[style=Interface]
template<class RootBasis, class TreePath>
auto subspaceBasis(const RootBasis& rootBasis, const TreePath& path);

template<class RootBasis, class... PathIndices>
auto subspaceBasis(const RootBasis& rootBasis, const PathIndices&... indices);
\end{lstlisting}

The interface is illustrated by the following
example which extracts the velocity field
from a Taylor--Hood basis.

\begin{lstlisting}[style=Example]
// Create Taylor-Hood basis as root basis
auto taylorHoodBasis = makeBasis(
  gridView,
  composite(
    power<dim>(
      lagrange<p+1>(),
      flatInterleaved()),
    lagrange<p>(),
    flatLexicographic()
  ));

// Setup and fill a coefficient vector x for the full taylorHoodBasis
auto x = @@<...>@@

// Create SubspaceBasis for the velocity field
auto velocityBasis = subspaceBasis(taylorHoodBasis, _0);

// Fix a range type for the velocity field
using VelocityRange = FieldVector<double,dim>;

// Create a function for the velocity field only
// still using the vector x for the full taylorHoodBasis.
auto velocityFunction = makeDiscreteGlobalBasisFunction<VelocityRange>(velocityBasis, x);
\end{lstlisting}

Notice that the function created in the last line can directly
be passed to the \cpp{VTKWriter} implementations of the
\dunemodule{dune-grid} module to write the velocity field
as VTK vector field. The interface for the construction of
a finite element function from a basis (or \cpp{SubspaceBasis})
and a coefficient vector is discussed in the next section.

\section{Combining global basis and coefficient vector to a finite element function}
\todograeser{Write this section}



\section{Interpolation}

In various parts of a finite element or finite volume simulation code, given functions need to be interpolated
into spaces spanned by a global basis.  For example, initial iterates may be given in closed form, but need to be
transfered to a finite element representation to be usable.  Similarly, Dirichlet values given in closed form
may need to be interpolated on the set of Dirichlet degrees of freedom.  Depending on the finite element space,
interpolation may take different forms.  Nodal interpolation is the natural choice for Lagrange elements, but
for other spaces $L^2$-projections or Hermite-type interpolation may be more appropriate.

The \dunemodule{dune-functions} module provides a set of methods for interpolation in the file
\file{dune/functions/functionspacebases/interpolation.hh}.  These methods are canonical in the sense that
they use the \cpp{LocalInterpolation} functionality on each element for the interpolation.  This is appropriate
for a lot, but not all finite element spaces.  For example, no reasonable local interpolation can be defined
for B-spline bases, and therefore the standard interpolation functionality cannot be used with the
\cpp{BSplineBasis} class.
This approach also fails for non-affine finite elements, where \cpp{LocalInterpolation} is
missing an essential transformation.

The interpolation functionality is implemented in two global functions.
The first is for the simple-most case, where you have a function,
a basis, and a coefficient vector, and you want to interpolate
the given function with respect to the basis.

\begin{lstlisting}[style=Interface]
template <class Basis, class C, class F>
void interpolate(const Basis& basis, C&& coeff, const F& f);
\end{lstlisting}

Notice that this will only work if the range type of \cpp{f},
and the global basis \cpp{basis} are compatible.
\dunemodule{dune-functions} implements a compatibility layer
that allows to use different vector (or matrix) types
from the dune core modules and scalar types like, e.g. \cpp{double}
for the range of \cpp{f} as long as the number of scalar entries
of this range type is the same as the dimension of the range space of
the function space spanned by the basis.
This also implies the assumption that the coefficients for
individual basis functions are scalar.

The \cpp{interpolate()} function
requires that \cpp{coeff} supports the \cpp{VectorBackend}
interface. That is, it implements the following methods.
\begin{lstlisting}[style=Interface]
  auto operator[](Basis::MultiIndex);
  void resize(const Basis&);
\end{lstlisting}
Here \cpp{operator[]} allows to access entries using the
global multi-indices provided by \cpp{basis} and \cpp{resize(basis)}
resizes the vector, such that entries exist for any multi-index
from the index tree of \cpp{basis}.

For the vector types implemented in the dune core modules and
the standard types \cpp{std::array} and \cpp{std::vector} such
a backend can be obtained using
\begin{lstlisting}[style=Interface]
  template<class SomeDuneVector>
  auto istlVectorBackend(SomeDuneVector& x);
\end{lstlisting}
To simplify using \cpp{interpolate()} for the supported vector types,
such a wrapper is created automatically if the passed coefficient
container \cpp{coeff} does not already satisfy the \cpp{VectorBackend}
interface. Hence you can either directly pass those supported
vector types or any other type implementing the \cpp{VectorBackend}
interface. The latter allows to use \dunemodule{dune-functions}
with other vector implementations.

For example, suppose you have the example function
\begin{equation*}
 f_1 : \R^d \to \R
 \qquad
 f_1 =  \exp(-\norm{x}^2)
\end{equation*}
implemented as
\todograeser{Update example code}
%
\lstinputlisting[linerange=definition_f1_begin-definition_f1_end,
                 numbers=left]{../../examples/interpolation.cc}
%
Additionally, say you have a scalar second-order Lagrange space
%
\lstinputlisting[linerange=definition_basis1_begin-definition_basis1_end,
                 numbers=left]{../../examples/interpolation.cc}
%
and an empty coefficient vector \cpp{x1}, not necessarily of correct size:
%
\lstinputlisting[linerange=definition_x1_begin-definition_x1_end,
                 numbers=left]{../../examples/interpolation.cc}
%
Then, the single line
%
\lstinputlisting[linerange=interpolation1_begin-interpolation1_end,
                 numbers=left]{../../examples/interpolation.cc}
%
will fill \cpp{x1} with the nodal values of the function \cpp{f1}.

If the function and the basis are vector-valued, this interpolation works just as well, provided you use
a matching coefficient vector
%
\lstinputlisting[linerange=interpolation2_begin-interpolation2_end,
                 numbers=left]{../../examples/interpolation.cc}
%
\todo[inline]{Kann ich auch mit einer kompletten Taylor--Hood-Basis interpolieren?}

In some situations it is also desirable to interpolate only on a part of the domain.  Algebraically, the interpolation
is performed as before, but only a subset of all coefficients are written.  The most frequent use-case is the interpolation
of Dirichlet data given in closed form onto the algebraic degrees of freedom on the Dirichlet boundary.  All others
degrees of freedom must not be touched, as they contain, e.g., a suitable initial iterate obtained by some other
means.

To support this kind of interpolation another variant of
\cpp{interpolate()} allows to explicitly mark a subset of
coefficient vector entries to be written.
\begin{lstlisting}[style=Interface]
template <class Basis, class C, class F, class BV>
void interpolate(const Basis& basis, C&& coeff, const F& f, const BV& bitVector)
\end{lstlisting}
Conceptually, the additional \cpp{bitVector}
argument must be a container of booleans having
the same structure as \cpp{coeff} and satisfying
the same assumptions.  Its entries are treated as boolean
values indicating if the corresponding entry of \cpp{coeff}
should be written.
For example, for flat global indices \cpp{std::vector<bool>} and
\cpp{std::vector<char>} work nicely.
The class \cpp{BitSetVector<N>} (from the \dunemodule{dune-common} module) can be used
as a space-optimized alternative to \cpp{std::vector<std::bitset<N>>}.


\todograeser{Update example code}
For example, to interpolate the scalar example function $f_1$ from above only on the boundary degrees of the scalar basis
\cpp{basis1}, write
%
\lstinputlisting[linerange=interpolation4_begin-interpolation4_end,
                 numbers=left]{../../examples/interpolation.cc}
%
To interpolate only into the $x$ and $y$ velocity components of a Taylor--Hood basis, write
%
\lstinputlisting[linerange=interpolation5_begin-interpolation5_end,
                 numbers=left]{../../examples/interpolation.cc}
%





\section{Example: Solving the Stokes equation with \dunemodule{dune-functions}}
\label{sec:stokes_example}

\subsection{The Stokes equation}

\begin{figure}
 \begin{center}
  \includegraphics[height=0.3\textheight]{driven_cavity}
  \qquad
  \includegraphics[height=0.3\textheight]{driven_cavity_result}
 \end{center}
 \caption{Driven cavity. Left: setting, right: simulation result.  The arrows show the {\em normalized} velocity.}
 \label{fig:driven_cavity}
\end{figure}

The Stokes equation models a viscous incompressible
fluid in a $d$-dimensional domain $\Omega$.  There are two unknowns in this problem: a stationary
fluid velocity field $\mathbf{u} : \Omega \to \R^d$, and the fluid pressure $p : \Omega \to \R$.
Together, they have to solve the boundary value problem
\begin{alignat*}{2}
 -\Delta \mathbf{u} - \nabla p & = 0  & \qquad & \text{in $\Omega$} \\
 \div \mathbf{u} & = 0                &        & \text{in $\Omega$} \\
                    \mathbf{u} & = \mathbf{u}_D  &        & \text{on $\partial \Omega$},
\end{alignat*}
where we have omitted the physical parameters.  The boundary value problem only determines the
pressure $p$ up to a constant function.  The pressure is therefore usually normalized such
that $\int_\Omega p\,dx = 0$.

Due to the constraint $\div \mathbf{u} = 0$, the corresponding weak form of the equation is a saddle-point problem.
Introduce the spaces
\begin{align*}
 \mathbf{H}^1_D(\Omega)
      & \colonequals
      \big\{ \mathbf{v} \in \mathbf{H}^1(\Omega) \; :\; \operatorname{tr}{\mathbf{v}} = \mathbf{u}_D \big\}, \\
 L_{2,0}(\Omega) & \colonequals  \Big\{ q \in L_2(\Omega) \; :\; \int_\Omega q\,dx = 0 \Big\},
\end{align*}
and the bilinear forms
\begin{equation*}
 a(\mathbf{u},\mathbf{v}) \colonequals \int_\Omega \nabla \mathbf{u} \nabla \mathbf{v} \,dx,
 \qquad \text{and} \qquad
 b(\mathbf{v},q) \colonequals \int_\Omega \div \mathbf{v} \cdot q \,dx.
\end{equation*}
Then the weak form of the Stokes equation is: Find $(\mathbf{u},p) \in \mathbf{H}_D^1(\Omega) \times L_{2,0}(\Omega)$ such that
\begin{alignat*}{2}
 a(\mathbf{u},\mathbf{v}) + b(\mathbf{v},p) & = 0 & \qquad & \text{for all $\mathbf{v} \in \mathbf{H}_0^1(\Omega)$} \\
 b(\mathbf{u},q)\qquad\qquad & = 0       &        & \text{for all $q \in L_{2,0}(\Omega)$}.
\end{alignat*}
If $\mathbf{u}_D$ is sufficiently smooth, this variational problem has a unique solution.
The Taylor--Hood element is the standard way to discretize this saddle point problem~\cite{braess:2013}.

\subsection{The driven-cavity benchmark}

For our example we choose to simulate a two-dimensional driven cavity.  This is a standard benchmark
for the Stokes problem in the literature.  Let $\Omega$ be the unit square $[0,1]^2$, and set the Dirichlet
boundary conditions for the velocity $\mathbf{u}$ to
\begin{equation*}
 \mathbf{u}(x)
 =
 \begin{cases}
  (0,1) & \text{if $x \in \{0\} \times [0,1]$} \\
  (0,0) & \text{elsewhere on $\partial \Omega$}.
 \end{cases}
\end{equation*}
The interpretation of this is a fluid container that is closed on all but one side.  While the fluid remains
motionless on the closed sides, an external agent drives a constant upward motion on the left vertical side.
The domain and boundary conditions are depicted in Figure~\ref{fig:driven_cavity}, left.
The corresponding solution is shown on the right side of the same figure.  The velocity forms a vortex,
while the pressure forms extrema in the two left corners.

In the following discussion we always use the letter $d$ to denote the space dimension, even though it is
known to be $d=2$ for our specific example.  This is to avoid confusion, because the number~2 also
appears a few times because we have two types of unknowns.

\subsection{Discretization}

We discretize the domain using a structured axis-aligned grid with $4 \times 4$ uniform quadrilateral elements.
On this grid, we use the Taylor--Hood element to discretize the weak saddle-point problem.  The nodal basis
of the Taylor--Hood element has a natural tree structure as shown in Figure~\ref{fig:taylor_hood_basis_tree}.
On each element, the \dunemodule{dune-functions} implementation provides a local numbering of all shape functions
on this element.  This numbering uses a simple integer as index type, and is used to address the entries of the
element stiffness matrix.

\begin{table}
 \begin{center}
 \begin{tabular}{c|c}
 basis function & multi-index \\
 \hline \\
  $b_{x,0}$  & $(0,0)$ \\
  $b_{y,0}$  & $(0,1)$ \\
  $b_{z,0}$  & $(0,2)$ \\
  $b_{x,1}$  & $(0,3)$ \\
  $b_{y,1}$  & $(0,4)$ \\
  $b_{z,1}$  & $(0,5)$ \\
  $b_{x,2}$  & $(0,6)$ \\
  $b_{y,2}$  & $(0,7)$ \\
  $b_{z,2}$  & $(0,8)$ \\
    \vdots   & \vdots  \\
  $p_0$      & $(1,0)$ \\
  $p_1$      & $(1,1)$ \\
  $p_2$      & $(1,2)$ \\
    \vdots   & \vdots
 \end{tabular}
 \end{center}
 \caption{Multi-index for the Taylor--Hood basis with interleaved ordering of the velocity basis functions}
 \label{tbl:th_multiindices_interleaved}
\end{table}

Each global basis function additionally gets a global index, used to address the entries of the global stiffness
matrix.  In principle, \dunemodule{dune-functions} provides several types of orderings and multi-indices here.
The one that is used in the code example is given  in Table~\ref{tbl:th_multiindices_interleaved}: Each global
index is a pair $(a,b)$, where $a \in \{0,1\}$ switches between velocity and pressure basis functions,
and $b \in \mathbb{N}$ selects a particular basis function in either the set of velocity basis functions
or the set of pressure basis functions.


\subsection{Implementation}

This chapter discusses an example implementation of the Stokes problem, using only \dunemodule{dune-functions}
and no higher-level modules.  The example is contained in a single file, which comes as part of the \dunemodule{dune-functions}
source tree, in \file{dune-functions/examples/stokes-taylorhood.cc}.  If you read this document in electronic form,
the file can also be accessed by clicking on the icon in the margin.%
%
\marginpar{\attachfile[author=The dune-functions team,
                       color = 1 0 0,
                       mimetype=text/plain,
                       description=Complete source code of the Stokes/Taylor-Hood example]
                       {../../examples/stokes-taylorhood.cc}}

\subsubsection{The \texorpdfstring{\cpp{main}}{main} method}

We begin discussing the example code by describing its \cpp{main} method.  This method begins by setting up MPI and the grid.
We pick \cpp{YaspGrid} for the structured $4 \times 4$ quadrilateral grid.  Note that there is the line
%
\lstinputlisting[linerange={using_namespace_dune_begin-using_namespace_dune_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
at the top of the file, so this namespace is imported completely.  Additionally, everything in the \dunemodule{dune-functions}
module is in the namespace \cpp{Functions}.  This namespace is not imported; instead, the prefix \cpp{Functions::} is always
given explicitly.


%
\lstinputlisting[linerange={main_begin-grid_setup_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
The \cpp{gridView} object is the flat finite element grid that we will use for
the computation.
On this grid view, we then set up the function space basis for the Taylor--Hood element.  This is as simple as
%
\lstinputlisting[linerange={function_space_basis_begin-function_space_basis_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
For each element, the \cpp{taylorHoodBasis} object will give us the tree of shape functions, and the corresponding local and global numberings.

Before being able to assemble the stiffness matrix of the Stokes system we need to pick suitable data structures
for the linear algebra.
The implementation of the Taylor--Hood basis selected in Line~\ref{li:stokes_taylorhood_select_taylorhoodbasis} orders the
velocity degrees of freedom before the pressure degrees of freedom.  Further, the velocity
components are interleaved.  The indexing scheme results from grouping degrees of freedom at the
tree root.  The resulting multi-indices all have length~2, and are given in Table~\ref{tbl:th_multiindices_interleaved}.
Consequently, the appropriate vector type is a pair of scalar vectors, one for the velocity and one for the pressure
degrees of freedom.  Analogously, the matrix must consist of $2 \times 2$ large sparse scalar matrices.
The following code sets up vector and matrix types for this, using the nesting machinery from \dunemodule{dune-istl}.
%
\lstinputlisting[linerange={linear_algebra_setup_begin-linear_algebra_setup_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
Other index types are possible and possibly desirable here.  These would correspond to other vector and
matrix data types.

Now that we have chosen the C++ types for the matrix and vector data structures we can actually assemble the system.
Assembling the right-hand-side vector \cpp{rhs} is easy, because, apart from the Dirichlet boundary data (which we
will insert later), all its entries are zero.  An all-zero vector of the correct type and size is set up by the
following lines
%
\lstinputlisting[linerange={rhs_assembly_begin-rhs_assembly_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
The \cpp{HierarchicVectorView} is a device that offers easier handling of arbitrarily nested vector data types.
In particular, it offers convenient resizing of an entire hierarchy of nested vectors.
The \cpp{taylorHoodBasis} object informs about the sizes of the corresponding finite element basis subtrees,
and Line~\ref{li:stokes_taylorhood_set_rhs_to_zero} fills the entire vector with zeros.

To obtain the stiffness matrix we first create an empty matrix object of the correct type.  The actual assembly
is factored out into a separate method.
%
\lstinputlisting[linerange={matrix_assembly_begin-matrix_assembly_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
As the matrix assembly is the central part of this example we explain it in detail below, after having covered the \cpp{main} method.

Suppose now that we have the correct stiffness matrix assembled in the object \cpp{stiffnessMatrix}.  We still need
to modify the linear system to include the Dirichlet information.
In a first step we need to determine all degrees of freedom with Dirichlet data.  These are all the velocity degrees of freedom
on the domain boundary.  We could do this by using the \cpp{LocalKey} object of each basis function
to single out all those that are assigned to a boundary entity.  However, on a simple domain as the unit square
used here it is easier to use a geometric criterion.  We first define a predicate that returns \cpp{true}
if a given global coordinate \cpp{x} is on the domain boundary:
%
\lstinputlisting[linerange={boundary_predicate_begin-boundary_predicate_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
The we interpolate this boolean-valued function in the space spanned by the velocity basis functions.
%
\lstinputlisting[linerange={interpolate_boundary_predicate_begin-interpolate_boundary_predicate_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
Observe how the \dunemodule{dune-functions} interface allows to interpolate C++11 lambdas, which makes the code
very short and readable.  The expression \cpp{TypeTree::treePath(_0,i)} selects the different coordinate
directions of the velocity basis from the tree representation given in Figure~\ref{fig:taylor_hood_basis_tree}.
As the bases for the velocity components are all the same, an ordinary integer \cpp{i} is sufficient to choose
one of them.  In contrast, the velocity and pressure bases are different C++ types, and a compile-time
construction is needed to choose between them.  The object \cpp{_0} is defined in
\file{dune/typetree/utility.hh} as (roughly)
\begin{lstlisting}[style=Interface]
std::integer_constant<std::size_t, 0> _0;
\end{lstlisting}
In the \cpp{TaylorHoodBasis} implementation, \cpp{_0} selects the velocity subtree and \cpp{_1} selects
the pressure subtree.

Finally, we define a function implementing the actual Dirichlet values function $\mathbf{u}_D$, and interpolate
that into the right-hand-side vector \cpp{rhs}.
%
\lstinputlisting[linerange={interpolate_dirichlet_values_begin-interpolate_dirichlet_values_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
The expression \cpp{TypeTree::treePath(_0)} demands that only velocity degrees of freedom are
interpolated.  The \cpp{isBoundary} vector given as the last argument restricts the interpolation
to only the boundary degrees of freedom.

The stiffness matrix is modified in a more manual fashion.  For each Dirichlet degree of freedom we need to fill the corresponding matrix row
with zeros, and write a~1 on the diagonal.  As only velocity
degrees of freedom have Dirichlet values, we need to modify the two upper matrix blocks only.
%
\lstinputlisting[linerange={set_dirichlet_matrix_begin-set_dirichlet_matrix_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
Finally, we can solve the linear system.  Efficiently solving the Stokes system is an art, which we do not want to
get into here.  Instead, we a GMRes solver, without any preconditioner at all.  This is known to converge,
albeit slowly.
\todo[inline]{Eigentlich peinlich.  Können wir nicht doch einen vernünftigen Löser nehmen?}
The advantage is that it can be written down in very few lines.
%
\lstinputlisting[linerange={stokes_solve_begin-stokes_solve_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
Observe how the \cpp{RestartedGMResSolver} object is completely oblivious to the fact that the matrix
has a two-level nesting structure.  On the other hand, dedicated Stokes solvers usually operate
on some sort of Schur complement, and hence they need direct access
to the four submatrices.  This can be elegantly done using the nested matrix type
used for the stiffness matrix.

Once the iterative solver has terminated, we write the result to a VTK file.  For this, we write the resulting velocity as a vector field,
and the resulting pressure as a scalar field.  We subsample the grid twice, because the \cpp{VTKWriter}
class natively only displays piecewise linear functions.
%
\lstinputlisting[linerange={stokes_output_begin-stokes_output_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
When run, this program produces a file called \file{function-stokes-result.vtu}.  The file can be opened in
\program{ParaView}, and the outcome looks like the image on the right in Figure~\ref{fig:driven_cavity}.

\subsubsection{The global assembler}

Now that we have covered the \cpp{main} method, we can turn to the assembler for the Stokes stiffness matrix.
As our main focus is the use of the \dunemodule{dune-functions} interfaces, the assembler
is the central part of our example.   We begin with the global assembler,
which is the routine \cpp{assembleStokesMatrix} called in Line~\ref{li:stokes_taylorhood_call_to_assemblestokesmatrix}
of the \cpp{main} method.
The global assembler sets up the matrix pattern, loops over all elements, and accumulates the element stiffness
matrices in the global matrix. The signature of the method is
%
\lstinputlisting[linerange={global_assembler_signature_begin-global_assembler_signature_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
The only arguments it gets are the finite element basis and the matrix to fill.  Observe that the Taylor--Hood basis is not
hard-wired here, so we could call the method with a different basis.
However, not surprisingly the assembler for the Stokes problem makes relatively tight assumptions on the basis tree
structure, so relatively little practical freedom is possible here.  Ideally, a global assembler should be fully
generic, and all knowledge about the current spaces and differential operators should be confined to the local
assembler.  Real discretization frameworks like \dunemodule{dune-pdelab} do achieve this separation,
but for our example here we are less strict, to avoid technicalities.

The first few lines of the \cpp{assembleStokesMatrix} method set up the matrix occupation pattern, and initialize the matrix with zeros.
%
\lstinputlisting[linerange={setup_matrix_pattern_begin-setup_matrix_pattern_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
The actual pattern assembly is implemented in a separate method \cpp{getOccupationPattern}.
It returns a $2 \times 2$ table of \cpp{MatrixIndexSet} objects.
\todo[inline]{Erklären?  Überspringen?  Anders implementieren?}
The four \cpp{BCRSMatrix} objects are initialized with these patterns in Line~\ref{li:stokes_taylorhood_setup_matrix_patterns}.
Line~\ref{li:stokes_taylorhood_set_matrix_to_zero}
fills the entire matrix with zeros.

Next comes the actual element loop.  We first request a \cpp{localView} object and a \cpp{localIndexSet} object
from the finite element basis:
%
\lstinputlisting[linerange={get_localview_begin-get_localview_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
After that, we start the loop over the grid elements.  For each element, we bind the \cpp{localView} object
to the element and the \cpp{localIndexSet} object to
the \cpp{localView}.  From now on all enquiries to the local view and index set will implicitly refer to this element.
%
\lstinputlisting[linerange={element_loop_and_bind_begin-element_loop_and_bind_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
We then create the element stiffness matrix, and call the separate method \cpp{getLocalMatrix} to fill.
By default, \dunemodule{dune-functions} supposes that the element stiffness matrix is dense and non-hierarchical,
and Line~\ref{li:stokes_taylorhood_select_element_matrix_type}
picks a suitable type for such a matrix.
%
\lstinputlisting[linerange={setup_element_stiffness_begin-setup_element_stiffness_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
The \cpp{getLocalMatrix} method is discussed in detail below.
In addition to the \cpp{elementMatrix} object, it gets only the \cpp{localView} object.  This object contains
all necessary information.

Finally, we loop over the entries of the element stiffness matrix and add them onto the global matrix.
%
\lstinputlisting[linerange={accumulate_global_matrix_begin-accumulate_global_matrix_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
The type returned in Lines~\ref{li:stokes_taylorhood_get_global_row_index} and~\ref{li:stokes_taylorhood_get_global_column_index}
for the global row and column indices is a multi-index.  It has length~2 for both velocity degrees of freedom and for
pressure degrees of freedom.  Observe how Line~\ref{li:stokes_taylorhood_scatter_matrix_indices} uses the length-2
multi-index to access the nested matrix type.  For vectors, this scattering of multi-indices is implemented
in general form in the \cpp{HierarchicVectorWrapper} class.

The preceding loops write in particular into the lower right matrix block, even though we know that for the Stokes
system this block contains only zeros.  A more optimized version of the code would leave out the lower right
submatrix altogether.

\subsubsection{The local assembler}

Finally, we investigate the method that assembles the element stiffness matrices.  Its signature is
%
\lstinputlisting[linerange={local_assembler_signature_begin-local_assembler_signature_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
As you see, it only receives the local view of the Taylor--Hood basis, expected to be bound to an element,
and the empty matrix.
The first few lines of the method gather some information about the element the method is to work on.
In particular, from the \cpp{localView} object it extracts the element itself, and the element's dimension and
geometry
%
\lstinputlisting[linerange={local_assembler_get_element_information_begin-local_assembler_get_element_information_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
Next, the element stiffness matrix is initialized.  The \cpp{localView} object knows the total number of
degrees of freedom of the element it is bound to, and since the matrix is scalar this is the correct
number of matrix rows and columns.
%
\lstinputlisting[linerange={initialize_element_matrix_begin-initialize_element_matrix_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
Finally, we first ask for the set of velocity and pressure shape functions.
%
\lstinputlisting[linerange={get_local_fe_begin-get_local_fe_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
The two objects are \cpp{LocalFiniteElement}s in the \dunemodule{dune-localfunctions} sense of the word.
In fact, they are objects of the
\cpp{LocalFiniteElementVirtualInterface} class.  The virtual interface of \dunemodule{dune-localfunctions} is used here
because the Taylor--Hood basis implementation accommodates grids with more than a single element type.

In Lines~\ref{li:stokes_taylorhood_get_velocity_lfe}--\ref{li:stokes_taylorhood_get_pressure_lfe} you see the tree structure of the Taylor--Hood basis in action again:
The expression
\begin{lstlisting}[style=Example]
localView.tree().child(_0,0)
\end{lstlisting}
returns the first child of the first child of the root, i.e., the basis for the $x_0$-component of the velocity field,
and
\begin{lstlisting}[style=Example]
localView.tree().child(_1)
\end{lstlisting}
is the basis for the pressure space.
As the root of the tree combines two different bases, we need to use the static identifiers \cpp{_0} and \cpp{_1}
from the \cpp{Dune::TypeTree::Indices} namespace to specify its children.  The inner node for the velocities
combines $d$ times the same basis, and hence the normal integer \cpp{0} can be used to address its first child.
Our implementation of the local Stokes assembler is actually ``cheating'', because it exploits the knowledge
that the same basis is used for all velocity components.  Therefore, only the first leaf of the velocity
subtree is acquired in Line~\ref{li:stokes_taylorhood_get_velocity_lfe}, and then used for all components.
Using separate local finite elements is wasteful because the same shape function values and gradients
would be computed multiple times.

Next, we construct a suitable quadrature rule and loop over the quadrature points.  The formula for the quadrature
order combines information about the element type, the shape functions, and the differential operator.
%
\lstinputlisting[linerange={begin_quad_loop_begin-begin_quad_loop_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
The quadrature loop starts like similar local assembler codes seen elsewhere.
First, we get the inverse transposed Jacobian
of the map from the reference element to the grid element, and the Jacobian determinant for the integral
transformation formula
%
\lstinputlisting[linerange={quad_loop_preamble_begin-quad_loop_preamble_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
With these preparations done, we can assemble the first part of the stiffness matrix,  corresponding to the
velocity--velocity coupling.  For two $d$-valued velocity basis functions $\bm{\varphi}_i^k = \mathbf{e}_k \varphi_i$
and $\bm{\varphi}_j^l = \mathbf{e}_l \varphi_j$ we need to compute
\begin{equation*}
 a(\bm{\varphi}_i^k, \bm{\varphi}_j^l)
 =
 \int_\Omega \nabla \bm{\varphi}_i^k \nabla \bm{\varphi}_j^l \,dx
 =
 \delta_{kl} \int_\Omega \nabla \varphi_i \nabla \varphi_j \,dx,
\end{equation*}
where $\varphi_i$ and $\varphi_j$ are the corresponding scalar basis functions.
The code first computes the derivatives of the velocity
shape functions at the current quadrature point,
and then uses the matrix in \cpp{jacobian} to transform the shape functions gradients to
gradients of the actual basis functions defined on the grid element.
%
\lstinputlisting[linerange={velocity_gradients_begin-velocity_gradients_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
Withe the velocity basis function gradients at hand we can assemble the velocity contribution
to the stiffness matrix.
%
\lstinputlisting[linerange={velocity_velocity_coupling_begin-velocity_velocity_coupling_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
Noteworthy here are the Lines~\ref{li:stokes_taylorhood_compute_vv_element_matrix_row}--\ref{li:stokes_taylorhood_compute_vv_element_matrix_column} which,
for two given shape functions from the finite element basis tree, compute the flat lexicographic numbering
used to index the element stiffness matrix.  The expression \cpp{child(_0,k)} singles out the tree leaf
for the \cpp{k}-th component of the velocity basis.  The loop variables \cpp{i} and \cpp{j} run over
the shape functions in this set, and
\begin{lstlisting}[style=Example]
localView.tree().child(_0,k).localIndex(i);
\end{lstlisting}
returns the corresponding scalar index for this shape function in the set of {\em all} shape functions
of the Taylor--Hood basis on this element.  Line~\ref{li:stokes_taylorhood_update_vv_element_matrix} then updates the corresponding (scalar)
element matrix entry with the correctly weighted product the two gradients $\nabla \varphi_i$
and $\nabla \varphi_j$.

Once this part is understood, computing, the velocity--pressure coupling terms is easy.
For a given velocity shape function $\bm{\varphi}_i^k$ and pressure shape function $\theta_j$ we need
to compute
\begin{equation*}
 b(\bm{\varphi}_i^k,\theta_j)
 =
 \int_\Omega \operatorname{div} \bm{\varphi}_i^k \cdot \theta_j\,dx
 =
 \int_\Omega \sum_{l=1}^d \frac{\partial (\bm{\varphi}_i^k)_l}{\partial x_l} \cdot \theta_j\,dx
 =
 \int_\Omega \frac{\partial \varphi_i}{\partial x_k} \cdot \theta_j\,dx
 =
 \int_\Omega (\nabla \varphi_i)_k \cdot \theta_j\,dx.
\end{equation*}
As additional information we need the values of the pressure basis functions $\{\theta_j\}$ at the
current quadrature point.  These are evaluated by the following two lines:
%
\lstinputlisting[linerange={pressure_values_begin-pressure_values_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
Then, the actual matrix assembly is
%
\lstinputlisting[linerange={velocity_pressure_coupling_begin-velocity_pressure_coupling_end},
                 numbers=left]{../../examples/stokes-taylorhood.cc}
%
Line~\ref{li:stokes_taylorhood_compute_vp_element_matrix_row} computes the flat lexicographic index of $\bm{\varphi}_i^k$,
and Line~\ref{li:stokes_taylorhood_compute_vp_element_matrix_column} computes the index for $\theta_j$ (remember that \cpp{_1} denotes
the pressure basis).  Finally, Lines~\ref{li:stokes_taylorhood_update_vp_element_matrix_a}--\ref{li:stokes_taylorhood_update_vp_element_matrix_b}
then add the resulting terms to the matrix.





\bibliographystyle{plainnat}
\bibliography{dune-functions-manual}

\end{document}

